<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConcurrentHashMap线程安全</title>
    <url>/2021/07/02/ConcurrentHashMap/</url>
    <content><![CDATA[<p>##1. jdk1.7 ConcurrentHashMap<br>jdk1.7 ConcurrentHashMap是由一个Segment数组和多个HashEntry数组组成<br><img src="/2021/07/02/ConcurrentHashMap/01.png" alt="image-20201210103251475"><br>其实就是将HashMap分为多个小HashMap,每个Segment元素维护一个小HashMap,目的是锁分离，本来实现同步，直接可以是对整个HashMap加锁，但是加锁粒度太大，影响并发性能，所以变换成此结构，仅仅对Segment元素加锁，降低锁粒度，提高并发性能</p>
<p>###1.1 初始化过程<br>由于变换成<strong>Segment数组+HashEntry数组</strong>，所以初始化时，需要依次对Segment数组和HashEntry数组初始化</p>
<ol>
<li><p>Segment数组初始化</p>
<p>初始化时，使用右移一位，乘以2的计算方式，保证ssize是2的幂次方，小于指定参数concurrencyLevel的最大2的幂次方</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//记录Segment数组大小</span></span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HashEntry数组初始化</p>
<p>跟Segment数组初始化方式相同</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cap &lt; c)&#123;</span><br><span class="line">    cap &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-put操作"><a href="#1-2-put操作" class="headerlink" title="1.2 put操作"></a>1.2 put操作</h3><p>对于插入操作，需要两次Hash映射去定位数据存储位置</p>
<ol>
<li>首先通过第一次hash过程，定位Segment位置 </li>
<li>然后通过第二次hash过程定位HashEntry位置</li>
</ol>
<p>Segment继承ReentrantLock,在数据插入指定HashEntry过程的时候会尝试调用ReentrantLock的tryLock方法获取锁，如果获取成功就直接插入相应位置，如果有线程获取该Segment的锁，当前线程就会以自旋方式去继续调用tryLock方法去获取锁，超过指定次数就挂起，等待唤醒。</p>
<h3 id="1-3-get操作"><a href="#1-3-get操作" class="headerlink" title="1.3 get操作"></a>1.3 get操作</h3><p>也是两次Hash映射，相对于put操作，少了加锁过程</p>
<h3 id="1-4-size操作"><a href="#1-4-size操作" class="headerlink" title="1.4 size操作"></a>1.4 size操作</h3><p>size操作就是计算ConcurrentHashMap的大小，有两种方案</p>
<ul>
<li>给每个Segment都加上锁(相当于给整个Map加上锁)，然后计算size返回</li>
<li>不加锁的模式，尝试多次计算ConcurrentHashMap的size,最多三次，比较前后计算的结果，结果一致就认为当前没有元素加入，计算结果是准确的。(查看计算出size的前后modCount的数值有没有发生变化，modCount的值用于记录元素变化的操作。如put，remove，clear)</li>
</ul>
<h2 id="2-jdk1-8-ConcurrentHashMap"><a href="#2-jdk1-8-ConcurrentHashMap" class="headerlink" title="2. jdk1.8 ConcurrentHashMap"></a>2. jdk1.8 ConcurrentHashMap</h2><p>jdk1.8ConcurrentHashMap是数组+链表，或者数组+红黑树结构,并发控制使用Synchronized关键字和CAS操作<br><img src="/2021/07/02/ConcurrentHashMap/02.png" alt="jdk1.8 ConcurrentHashMap"></p>
<h3 id="2-1关键概念点"><a href="#2-1关键概念点" class="headerlink" title="2.1关键概念点"></a>2.1关键概念点</h3><ul>
<li>sizeCtl变量(volatile修饰)<br> 通过CAS操作+volatile, 控制数组初始化和扩容操作<ul>
<li>-1 代表正在初始化</li>
<li>-N 前16位记录数组容量，后16位记录扩容线程大小+1，是个负数</li>
<li>正数0，表示未初始化</li>
<li>正数，0.75*当前数组大小</li>
</ul>
</li>
<li>&lt;key,value&gt;键值对，封装为Node对象</li>
<li>table变量(volatile)：也就是所说的数组，默认为null，默认大小为16的数组，每次扩容时大小总是2的幂次方</li>
<li>nextTable(volatile):扩容时新生成的数组，大小为table的两倍</li>
</ul>
<h3 id="2-2put函数"><a href="#2-2put函数" class="headerlink" title="2.2put函数"></a>2.2put函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.putValue函数</strong><br>首先调用spread函数，计算hash值，之后进入一个自旋循环过程，直到插入或替换成功，才会返回。如果table未被初始化，则调用initTable进行初始化。之后判断hash映射的位置是否为null,如果为null,直接通过CAS自旋操作，插入元素成功，则直接返回，如果映射的位置值为MOVED(-1),则直接去协助扩容，排除以上条件后，尝试对链头Node节点f加锁，加锁成功后，链表通过尾插遍历，进行插入或替换。红黑树通过查询遍历，进行插入或替换。之后如果当前链表节点数量大于阈值，则调用treeifyBin函数，转换为红黑树最后通过调用addCount,执行CAS操作，更新数组大小，并且判断是否需要进行扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//spread函数计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋过程</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//判断映射位置节点是否为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果映射位置节点value==MOVED，说明正在进行扩容操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//链表节点数量超过阈值，转为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. spread函数</strong><br>spread函数，计算hash值。key的hash值与其高16位相异或，然后与HASH_BITS将最高位置0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    <span class="comment">//HASH_BITS=0x7fffffff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. tableAt函数</strong><br>获取最新的tab[i]</p>
<p><strong>4. casTabAt函数</strong><br>通过CAS操作，将值赋值进tab中对应位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. addCount函数</strong><br>尝试使用CAS操作，将BASECOUNT加1，操作失败，则说明有其他线程在进行加一操作,发生冲突。之后判断是否需要扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//使用CAS操作，将BASECOUNT加1</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//发生冲突</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//多线程冲突执行</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//判断是否需要扩容  大于0.75当前数组大小</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//判断是否需要帮助扩容</span></span><br><span class="line">                <span class="comment">//扩容完成，或者扩容线程达到阈值不需要进行扩容，直接break</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//帮助扩容，扩容线程数+1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-initTable函数"><a href="#2-3-initTable函数" class="headerlink" title="2.3 initTable函数"></a>2.3 initTable函数</h3><p>进入一个自旋过程，一旦有线程扩容成功，才break</p>
<ul>
<li>如果sizeCtl &lt; 0,说明已经有线程正在扩容，所以直接让出线程。</li>
<li>如果sizeCtl&gt;=0,说明当前没有线程扩容，尝试CAS操作，设置sizeCtl为-1</li>
<li>设置sizeCtl为-1成功的线程，进行扩容操作，并且将sc更新为数组负载阈值0.75*n<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋过程</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//0.75*n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-统计ConCurrentHashMap中的元素个数"><a href="#2-4-统计ConCurrentHashMap中的元素个数" class="headerlink" title="2.4 统计ConCurrentHashMap中的元素个数"></a>2.4 统计ConCurrentHashMap中的元素个数</h3><p><strong>1. mappingCount函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用sumCount,获得元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> n = sumCount();</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. sumCount函数</strong></p>
<p>baseCount+ counterCells各个元素值，就是元素数量<br>其实baseCount就是记录容器数量的，直接放回baseCount不就可以了吗？为什么sumCount()方法中还要遍历counterCells数组，累加对象的值呢？<br>其中：counterCells是个全局的变量，表示的是CounterCell类数组。CounterCell是ConcurrentHashmap的内部类，它就是存储一个值。<br>JDK1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据put()或则删除数据remove()时，会通过addCount()方法更新baseCount<br>初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，执行fullAddCount(x, uncontended)方法，这个方法其实就是初始化counterCells，并将x的值插入到counterCell类中，而x值一般也就是1或-1，这可以从put()方法中得知。<br>这些对象是因为在CAS更新baseCount值时，由于高并发而导致失败，最终将值保存到CounterCell中，放到counterCells里。这也就是为什么sumCount()中需要遍历counterCells数组，sum累加CounterCell.value值了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. CounterCell类</strong><br>只存储一个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span></span>&#123;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">   CountCell(<span class="keyword">long</span> x) &#123;value = x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>原文链接：<a href="https://blog.csdn.net/zycxnanwang/article/details/105424734">https://blog.csdn.net/zycxnanwang/article/details/105424734</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch安装</title>
    <url>/2021/07/23/ElasticSearch/</url>
    <content><![CDATA[<h2 id="1-JDK14安装"><a href="#1-JDK14安装" class="headerlink" title="1. JDK14安装"></a>1. JDK14安装</h2><ol>
<li><p>下载jdk14：  <a href="https://jdk.java.net/14/">https://jdk.java.net/14/</a></p>
</li>
<li><p>将文件存放在linux系统某文件夹内</p>
</li>
<li><p>解压</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf openjdk-14.0.2_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>配置环境变量</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#在文件最末尾添加，其中JAVA_HOME是jdk解压后的文件路径</span></span></span><br><span class="line">JAVA_HOME=/usr/lib/tools/jdk-14.0.2</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure></li>
<li><p>保存后，更新配置文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li>
<li><p>查看JDK是否配置完成</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>出现下图表示安装成功！</p>
<p><img src="/2021/07/23/ElasticSearch/image-20200806170145844.png" alt="image-20200806170145844"></p>
</li>
</ol>
<h2 id="2-ElasticSearch安装"><a href="#2-ElasticSearch安装" class="headerlink" title="2. ElasticSearch安装"></a>2. ElasticSearch安装</h2><ol>
<li><p>解压tar.gz包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>添加elasticsearch用户</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd elastic</span><br></pre></td></tr></table></figure></li>
<li><p>赋予elastic search操作文件夹的权限</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R elastic:elastic /usr/lib/tools/elasticsearch-7.8.0/*</span><br></pre></td></tr></table></figure></li>
<li><p>查看本机的hostname</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostname</span><br><span class="line"><span class="meta">#</span><span class="bash">localhost.localdomain</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改elastic search配置</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> cd ./elasticsearch-7.8.0/config</span><br><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure>

<p><strong>elasticsearch.yml</strong></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#集群名称，默认可以不修改，此处 xiaoyuge</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">xiaoyuge</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#节点名称，必须修改 ，默认修改为当前机器名称，若是多实例则需要区分</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">xiaoyuge-local1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment">##数据目录与日志目录，默认在当前运行程序下，生产环境需要指定</span></span><br><span class="line"><span class="comment">#path.data: /path/to/data</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#path.logs: /path/to/logs</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#内存交换锁定，此处需要操作系统设置才生效</span></span><br><span class="line"><span class="comment">#bootstrap.memory_lock: true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#IP 地址，默认是 local，仅限本机访问，外网不可访问，设置 0.0.0.0 通用做法</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.135</span><span class="number">.111</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#访问端口，默认 9200，9300，建议明确指定</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span></span><br><span class="line"><span class="comment">## 集群发现配置</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;192.168.135.111:9300&quot;</span>]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;192.168.135.111:9300&quot;</span>]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#gateway.recover_after_nodes: 3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">##防止批量删除索引</span></span><br><span class="line"><span class="attr">action.destructive_requires_name:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#设置密码</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.license.self_generated.type:</span> <span class="string">trial</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">http.cors.allow-headers:</span> <span class="string">Authorization</span></span><br></pre></td></tr></table></figure></li>
<li><p>切换为elastic search用户，然后启动elastic search</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su elastic			#切换用户</span><br><span class="line">./bin/elasticsearch -d      #后台启动</span><br></pre></td></tr></table></figure></li>
<li><p>设置密码</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-setup-passwords interactive</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行设置用户名和密码的命令,这里需要为4个用户分别设置密码，elastic, kibana, logstash_system,beats_system</span></span><br><span class="line">Initiating the setup of passwords for reserved users elastic,kibana,logstash_system,beats_system.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line">Enter password for [elastic]:</span><br><span class="line">passwords must be at least [6] characters long</span><br><span class="line">Try again.</span><br><span class="line">Enter password for [elastic]:</span><br><span class="line">Reenter password for [elastic]:</span><br><span class="line">Passwords do not match.</span><br><span class="line">Try again.</span><br><span class="line">Enter password for [elastic]:</span><br><span class="line">Reenter password for [elastic]:</span><br><span class="line">Enter password for [kibana]:</span><br><span class="line">Reenter password for [kibana]:</span><br><span class="line">Enter password for [logstash_system]:</span><br><span class="line">Reenter password for [logstash_system]:</span><br><span class="line">Enter password for [beats_system]:</span><br><span class="line">Reenter password for [beats_system]:</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>常见异常：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">java.lang.RuntimeException: can not run elasticsearch as root</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">切换为elastic search用户，不能用root项目启动</span></span><br><span class="line">  </span><br><span class="line">su elastic</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.nio.file.AccessDeniedException: /usr/lib/tools/elasticsearch-7.8.0/config/elasticsearch.keystore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elastic search用户没有操作该文件夹的权限</span></span><br><span class="line">  </span><br><span class="line">su root</span><br><span class="line">chown -R elastic:elastic /usr/lib/tools/elasticsearch-7.8.0/*</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR: [2] bootstrap checks failed</span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</span><br><span class="line">[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span><span class="bash">分配内存不够</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1. 修改 /etc/security/limits.conf</span></span><br><span class="line">sudo vi /etc/security/limits.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾加上</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 4096</span><br><span class="line">* hard nproc 4096</span><br><span class="line"><span class="meta">#</span><span class="bash">2. 修改 /etc/sysctl.conf</span></span><br><span class="line">sudo vi /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾增加</span></span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"><span class="meta">#</span><span class="bash">3. 配置重新生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p><strong>效果如下：</strong></p>
<p><img src="/2021/07/23/ElasticSearch/image-20200807093208470.png" alt="image-20200807093208470"></p>
<h2 id="3-Kibana安装"><a href="#3-Kibana安装" class="headerlink" title="3. Kibana安装"></a>3. Kibana安装</h2><ol>
<li><p>解压文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf kibana-7.8.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ./config/kibana.yml</span><br></pre></td></tr></table></figure>

<p><strong>kibana.yml:</strong></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kibana is served by a back end server. This setting specifies the port to use.</span></span><br><span class="line"><span class="comment">##访问端口，默认无需修改</span></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span></span><br><span class="line"><span class="comment"># The default is &#x27;localhost&#x27;, which usually means remote machines will not be able to connect.</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="comment">#访问地址 IP，默认本地 ;如果需要外网访问，则配置0.0.0.0</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you to specify a path to mount Kibana at if you are running behind a proxy.</span></span><br><span class="line"><span class="comment"># Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath</span></span><br><span class="line"><span class="comment"># from requests it receives, and to prevent a deprecation warning at startup.</span></span><br><span class="line"><span class="comment"># This setting cannot end in a slash.</span></span><br><span class="line"><span class="comment">#server.basePath: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies whether Kibana should rewrite requests that are prefixed with</span></span><br><span class="line"><span class="comment"># `server.basePath` or require that they are rewritten by your reverse proxy.</span></span><br><span class="line"><span class="comment"># This setting was effectively always `false` before Kibana 6.3 and will</span></span><br><span class="line"><span class="comment"># default to `true` starting in Kibana 7.0.</span></span><br><span class="line"><span class="comment">#server.rewriteBasePath: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum payload size in bytes for incoming server requests.</span></span><br><span class="line"><span class="comment">#server.maxPayloadBytes: 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Kibana server&#x27;s name.  This is used for display purposes.</span></span><br><span class="line"><span class="comment">#server.name: &quot;your-hostname&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The URLs of the Elasticsearch instances to use for all your queries.</span></span><br><span class="line"><span class="comment"># ES 服务指向，集群下配置多个</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://192.168.135.111:9200&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># When this setting&#x27;s value is true Kibana uses the hostname specified in the server.host</span></span><br><span class="line"><span class="comment"># setting. When the value of this setting is false, Kibana uses the hostname of the host</span></span><br><span class="line"><span class="comment"># that connects to this Kibana instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.preserveHost: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kibana uses an index in Elasticsearch to store saved searches, visualizations and</span></span><br><span class="line"><span class="comment"># dashboards. Kibana creates a new index if the index doesn&#x27;t already exist.</span></span><br><span class="line"><span class="comment"># Kibana 元数据存储索引名字，默认.kibana 无需修改</span></span><br><span class="line"><span class="comment">#kibana.index: &quot;.kibana&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default application to load.</span></span><br><span class="line"><span class="comment">#kibana.defaultAppId: &quot;home&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If your Elasticsearch is protected with basic authentication, these settings provide</span></span><br><span class="line"><span class="comment"># the username and password that the Kibana server uses to perform maintenance on the Kibana</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash"> 当前窗口内启动</span></span><br><span class="line"> ./bin/kibana# </span><br><span class="line"><span class="meta">#</span><span class="bash">后台进程启动</span></span><br><span class="line">nohup ./bin/kibana &amp;</span><br></pre></td></tr></table></figure>

<p><strong>效果如下</strong></p>
<p><img src="/2021/07/23/ElasticSearch/image-20200807093309761.png" alt="image-20200807093309761"></p>
</li>
</ol>
<p><strong>遇见问题：</strong></p>
<ul>
<li><p>root启动报错<img src="/2021/07/23/ElasticSearch/image-20201211095101816.png" alt="image-20201211095101816"></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换到elastic账户</span></span><br><span class="line">su xiaoyuge</span><br></pre></td></tr></table></figure></li>
<li><p>elastic用户权限不足 <strong>Babel could not write cache to file: /usr/share/kibana/optimize/.babel_register_cache.json</strong><img src="/2021/07/23/ElasticSearch/image-20201211095258901.png" alt="image-20201211095258901"></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换到root用户</span></span><br><span class="line">su root </span><br><span class="line"><span class="meta">#</span><span class="bash">赋予elastic账户 xiaoyuge操作权限</span></span><br><span class="line">chown -R xiaoyuge /usr/local/kibana-7.7.1-linux-x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash">切换为elastic账户</span></span><br><span class="line">su xiaoyuge</span><br><span class="line"><span class="meta">#</span><span class="bash">再次启动即可</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/08/19/algorithm/</url>
    <content><![CDATA[<p>二分法查找是一种基于比较目标值和数组中间元素的算法</p>
<ul>
<li>如果目标值 = 中间值，则找到目标值</li>
<li>如果目标值 &lt; 中间值，则在左侧继续搜索</li>
<li>如果目标值 &gt; 中间值，则在右侧继续搜索<br><img src="/2021/08/19/algorithm/01.png" alt="二分查找"></li>
</ul>
<p><strong>解题思路：</strong></p>
<ul>
<li>初始化指针left = 0, right=n-1;</li>
<li>当left &lt;= right： <ul>
<li>比较中间元素nums[pivot]和目标值target<br>1.target = nums[pivot], 返回pivot<br>2.target &gt; nums[pivot], 则在右侧继续搜索left = pivot+1<br>3.target &lt; nums[pivot], 则在左侧继续搜索right = pivot+1<br><img src="/2021/08/19/algorithm/02.png"><br><img src="/2021/08/19/algorithm/03.png"></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot, left =<span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[pivot] &lt; target)&#123;</span><br><span class="line">            left = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            right = pivot - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(logN) </li>
<li>空间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>springCloud之FeignClient访问微服务接口缓慢</title>
    <url>/2021/07/03/bug-sprigCloud/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>逻辑是A服务调用B服务(AB在同一个局域网内)。 经过反复测试，有一个访问缓慢的现象，具体表现为：<br>程序启动第一次访问初始化1.2秒左右，还可以理解。<br>但后面访问还是要1.1秒左右（格式化到SSS毫秒打印日志监控的）。<br>但如果连续访问几次，后面几次又是几十毫秒。过一会再访问，或者换浏览器换post工具请求，又会1.2秒左右。</p>
<h3 id="原因排查1"><a href="#原因排查1" class="headerlink" title="原因排查1"></a>原因排查1</h3><p>查看连接查实的接口<br><img src="/2021/07/03/bug-sprigCloud/02.png" alt="请求缓慢2"><br>发现接口调用的是这个地址，其实是别人启动项目的时候吧自己的ip注册到了eureka注册中心，导致接口有时候走的是getway，有时候又是走的别人的接口</p>
<p>解决方法：eureka.client.register-with-eureka 为false  这样就不会注册到eureka注册中心了</p>
<h3 id="原因排查2"><a href="#原因排查2" class="headerlink" title="原因排查2"></a>原因排查2</h3><ol>
<li>查看日志<br> <img src="/2021/07/03/bug-sprigCloud/01.png" alt="请求缓慢"><br>查看是否是hystrix 配置的时间小于了ribbon的时间</li>
</ol>
]]></content>
      <categories>
        <category>问题点</category>
        <category>sprigCloud</category>
      </categories>
      <tags>
        <tag>问题点</tag>
      </tags>
  </entry>
  <entry>
    <title>java缓存一致性问题</title>
    <url>/2021/08/11/cache-consistency/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>中间件</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA类加载过程</title>
    <url>/2021/07/31/classLoad/</url>
    <content><![CDATA[<h2 id="1-类加载机制"><a href="#1-类加载机制" class="headerlink" title="1.类加载机制"></a>1.类加载机制</h2><p>JVM将类描述数据从.class文件中加载到内存，并对数据进行解析、初始化，最终形成被JVM直接使用的Java类型；类从被加载到JVM中开始，到卸载为止，<br>整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>7个阶段<br><img src="/2021/07/31/classLoad/01.png" alt="完整的类加载过程"></p>
<ol>
<li><p>加载</p>
<p> 加载时jvm做了三件事</p>
<ul>
<li>1)通过一个类的全限定名获取该类的二进制流</li>
<li>2)将这个字节流的静态存储结构转化为方法区运行时数据结构</li>
<li>3)在内存堆中生成一个代表该类的java.lang.class对象，最为该类数据的访问入口</li>
</ul>
</li>
<li><p>验证</p>
<p> 验证、准备、解析这三步可以看作是一个连接的过程，将类的字节码连接到JVM的运行黄台之中;  验证是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，不会威胁到jvm的安全。<br>验证内容如下：</p>
<ul>
<li>文件格式的验证： 验证字节流是否符合class文件袋额规范，是否能被当前版本的虚拟机处理</li>
<li>元数据验证： 对字节码描述的信息进行语义分析，确保符合Java语言规范</li>
<li>字节码验证：通过数据流和控制流分析，确定寓意是否合法，符合逻辑的</li>
<li>符号引用验证：这个娇艳在解析阶段发生</li>
</ul>
</li>
<li><p>准备</p>
<p> 为类的静态变量分配内存，设置初始值，对于final static修饰的变量，直接赋值为用户的定义值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备阶段过后的初始值为0， 而不是7</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>解析</p>
<p> 解析是将常量池内的符号引用转化为直接引用（如物理内存地址指针）</p>
</li>
<li><p>初始化</p>
<p> 初始化阶段，jvm才开始真正执行类中定义的Java代码</p>
<ul>
<li>执行类构造器<clinit>()方法的过程，类构造器方法是有编译器自动手机类中所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的</clinit></li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，需有限触发其父类的初始化</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境被正确加锁和同步<br><img src="/2021/07/31/classLoad/02.png" alt="完整的类加载过程2"></clinit></li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.类加载器"></a>2.类加载器</h2><p>类加载器的主要任务：对类加载过程中的加载操作（根据一个类的全限定名读取该类的二进制字节流到JVM内部，然后转换为一个对应的java.lang.Class对象实例）</p>
<p>类加载器的分类</p>
<ul>
<li>启动类加载器Bootstrap ClassLoader:<br>在HotSpot虚拟机中，Bootstrap ClassLoader用C++语言编写并嵌入JVM内部，主要负载加载JAVA_HOME/lib目录中的所有类，或者加载由选项-Xbootcalsspath指定的路径下的类</li>
<li>拓展类加载器/ExtClassLoader：<br>ExtClassLoader继承ClassLoader类，负载加载JAVA_HOME/lib/ext目录中的所有类型，或者由参数-Xbootclasspath指定路径中的所有类型</li>
<li>应用程序类加载器/AppClassLoader:<br>ExtClassLoader继承ClassLoader类，负责加载用户类路径ClassPath下的所有类型，一般情况下为程序的默认类加载器</li>
<li>自定义加载器:<br>Java虚拟机规范将所有继承抽象类java.lang.ClassLoader的类加载器，定义为自定义类加载器</li>
</ul>
<h2 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3. 双亲委派模型"></a>3. 双亲委派模型</h2><p><img src="/2021/07/31/classLoad/03.png" alt="双亲委派模型"><br>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式 。</p>
<ul>
<li>除了启动类加载器以外，每个类加载器拥有一个父类加载器，用户的自定义类加载器的父类加载器是AppClassLoader；</li>
<li>双亲委派模型可以保证全限名指定的类，只被加载一次；</li>
<li>双亲委派模型不具有强制性约束，是Java设计者推荐的类加载器实现方式；</li>
</ul>
<h3 id="3-1-双亲委派模式优势"><a href="#3-1-双亲委派模式优势" class="headerlink" title="3.1 双亲委派模式优势"></a>3.1 双亲委派模式优势</h3><ol>
<li>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次</li>
<li>java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改</li>
<li>如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常</li>
</ol>
<h3 id="3-2-双庆委派模型实现源码"><a href="#3-2-双庆委派模型实现源码" class="headerlink" title="3.2 双庆委派模型实现源码"></a>3.2 双庆委派模型实现源码</h3><p>可以打开 java.lang.ClassLoader 类，其 loadClass方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实现方式很简单，首先会检查该类是否已经被加载过了，若加载过了直接返回（默认resolve取false）；若没有被加载，则调用父类加载器的 loadClass方法，若父类加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则在抛出 ClassNotFoundException 异常后，在调用自己的 findClass 方法进行加载</p>
<h2 id="4-自定义类加载器"><a href="#4-自定义类加载器" class="headerlink" title="4.自定义类加载器"></a>4.自定义类加载器</h2><ol>
<li><p>加密</p>
<p>我们知道Java字节码是可以进行反编译的，在某些安全性高的场景，是不允许这种情况发生的。那么我们可以将编译后的代码用某种加密算法进行加密，加密后的文件就不能再用常规的类加载器去加载类了。而我们自己可以自定义类加载器在加载的时候先解密，然后在加载</p>
</li>
<li><p>动态创建</p>
<p>比如很有名的动态代理。</p>
</li>
<li><p>从非标准的来源加载代码<br>我们不用非要从class文件中获取定义此类的二进制流，还可以从数据库，从网络中，或者从zip包等。</p>
</li>
</ol>
<h3 id="4-1-自定义类加载器方法"><a href="#4-1-自定义类加载器方法" class="headerlink" title="4.1 自定义类加载器方法"></a>4.1 自定义类加载器方法</h3><p>   类加载时根据双亲委派模型会先一层层找到父加载器，如果加载失败，则会调用当前加载器的 findClass() 方法来完成加载。因此我们自定义类加载器，有两个步骤：<br>   1、继承 ClassLoader</p>
<p>   2、覆写 findClass() 方法</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署出现错误Error Spawn failed解决方式</title>
    <url>/2021/08/15/hexo-spawn-failed/</url>
    <content><![CDATA[<p>部署过程中可能会出现错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br><span class="line">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span><br><span class="line">fatal: unable to access &#x27;https://github.com/xiaoyuge5201/xiaoyuge5201.github.io.git/&#x27;: The requested URL returned error: 403</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (/Users/xiaoyuge/workspace/mybolg/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br><span class="line">xiaoyuge@xiaoyugedeMacBook-Pro mybolg % hexo clean</span><br></pre></td></tr></table></figure>
<p>####解决方式一：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#进入站点根目录</span></span></span><br><span class="line">cd cd /Users/xiaoyuge/workspace/mybolg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#删除git提交内容文件夹</span></span></span><br><span class="line">rm -rf .deploy_git/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#执行</span></span></span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#最后</span></span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>####解决方式二：<br>有可能是你的git repo配置地址不正确,可以将http方式变更为ssh方式（我的就是这个问题）<br>github在2021-08-13正式启用personal access token后，原来的用户名+密码方式部署会报错，需要采用最新的token登录方式进行部署 。<br>具体方式参考：<a href="https://cloud.tencent.com/developer/article/1861466">https://cloud.tencent.com/developer/article/1861466</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br></pre></td></tr></table></figure>
<p>查看_config.yml文件，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment">#repo:https://github.com/xiaoyuge5201/xiaoyuge5201.github.io.git  这是原来的路径，现在改成了下面这种</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xiaoyuge5201/xiaoyuge5201.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见的趣味题</title>
    <url>/2021/06/14/interest/</url>
    <content><![CDATA[<h3 id="8升、5升、3升水桶各一个-如何分成两个4升"><a href="#8升、5升、3升水桶各一个-如何分成两个4升" class="headerlink" title="8升、5升、3升水桶各一个,如何分成两个4升"></a>8升、5升、3升水桶各一个,如何分成两个4升</h3><p><img src="/2021/06/14/interest/3_5_8.png" alt="分成两个4升"></p>
<h3 id="以面向对象的思想设计长方形和正方形"><a href="#以面向对象的思想设计长方形和正方形" class="headerlink" title="以面向对象的思想设计长方形和正方形"></a>以面向对象的思想设计长方形和正方形</h3><ul>
<li>方式1：设计接口，然后长方形和正方形各自实现这个接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形状类：结算面积和周长</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//长方形：实现接口并实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> width,<span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.width=width;</span><br><span class="line">		<span class="keyword">this</span>.height=height;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.width*<span class="keyword">this</span>.height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">perimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>*(<span class="keyword">this</span>.width+<span class="keyword">this</span>.height);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正方形：实现接口并实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> side;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.side=side;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> side*side;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">perimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>*side;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式2：使用extents<br>因为正方形 <strong>is a</strong> 长方形，所以可以使用继承来设计正方形，然后在构造函数中使用super函数；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> side;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(side,side);</span><br><span class="line">		<span class="keyword">this</span>.side=side;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Square s=<span class="keyword">new</span> Square(<span class="number">2.5</span>);</span><br><span class="line">		System.out.println(s.perimeter());</span><br><span class="line">		System.out.println(s.area());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java使用递归计算1-2-3-…-n之间的和"><a href="#java使用递归计算1-2-3-…-n之间的和" class="headerlink" title="java使用递归计算1+2+3+…+n之间的和"></a>java使用递归计算1+2+3+…+n之间的和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sumN(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归的方法计算1+2+3+4+....n的和; 切记注意n不能小于1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+ sumN(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java读取一篇英文文章，并输出其中出现单词次数最多的3个单词以及次数"><a href="#java读取一篇英文文章，并输出其中出现单词次数最多的3个单词以及次数" class="headerlink" title="java读取一篇英文文章，并输出其中出现单词次数最多的3个单词以及次数"></a>java读取一篇英文文章，并输出其中出现单词次数最多的3个单词以及次数</h3><p>文件文章中存在,.以及空格</p>
<ul>
<li>读取文件内容</li>
<li>对文件进行内容匹配</li>
<li>使用map 保存单词、次数</li>
<li>map排序</li>
<li>输出<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 使用流读取文件</span></span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;d:/n.txt&quot;</span>));</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            <span class="comment">//替换所有的英文逗号和句号</span></span><br><span class="line">            String temp = sb.toString().replaceAll(<span class="string">&quot;/[\\w\\,\\.]+/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//2.使用正则表达式匹配</span></span><br><span class="line">            Pattern pattern = Pattern.compile(<span class="string">&quot;/[a-zA-Z\\w\\,\\.]+/&quot;</span>);</span><br><span class="line">            Matcher matcher = pattern.matcher(temp);</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">            String word;</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                word = matcher.group();</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(word)) &#123;</span><br><span class="line">                    count = map.get(word);</span><br><span class="line">                    map.put(word, count + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(word, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将map的数据根据count排序；</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">            Collections.sort(list, Comparator.comparing(Map.Entry::getValue));</span><br><span class="line">            <span class="keyword">int</span> last = list.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt; last - <span class="number">5</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;key=&quot;</span> + list.get(i).getKey() + <span class="string">&quot; value=&quot;</span> + list.get(i).getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="java-获取字符串第一次出现重复的字符"><a href="#java-获取字符串第一次出现重复的字符" class="headerlink" title="java 获取字符串第一次出现重复的字符"></a>java 获取字符串第一次出现重复的字符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    Set&lt;Character&gt; uniqueChars = <span class="keyword">new</span> HashSet(chars.length,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uniqueChars.add(chars[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>趣味</category>
      </categories>
  </entry>
  <entry>
    <title>Java内部类初始化</title>
    <url>/2021/06/01/java-inner-class-01/</url>
    <content><![CDATA[<h3 id="1-在同个java文件中，但不是内部类"><a href="#1-在同个java文件中，但不是内部类" class="headerlink" title="1. 在同个java文件中，但不是内部类"></a>1. 在同个java文件中，但不是内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在同一个Java文件中只能存在一个public类，除内部类外</span></span><br><span class="line"><span class="comment">//只允许使用“public”、“abstract”和“final”。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-常规内部类"><a href="#2-常规内部类" class="headerlink" title="2. 常规内部类"></a>2. 常规内部类</h3><p>要实例化内部类对象，必须先有外部类对象，通过外部类对象.new 内部类();来实例化内部类对象，在其他文件或者其他包内都是这样，只是要能在其他包实例化的话，内部类Inner还得加上修饰符public。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner in = out.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况：通过提供方法来获取实例对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="number">111</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = a.getInstance();</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h3><p>实例化静态内部类和实例化常规内部类有类似的地方，而不同之处在与静态内部类由于是静态的，所以不需要外部类对象就可以实例化，如上例Outter.Inner in = new Outter.Inner();<br>在其他Java文件也是这么实例化的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter.Inner in = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4. 局部内部类"></a>4. 局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内，所以只能在方法或者该作用域内实例化,局部内部类不能有访问说明符,因为它不是外围类的一部分,但是可以访问当前代码块的常量,以及此外围类的所有成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pint</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span> D();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-匿名内部类"><a href="#5-匿名内部类" class="headerlink" title="5. 匿名内部类"></a>5. 匿名内部类</h3><p>匿名内部类可以继承一个类或实现一个接口，这里的ClassOrInterfaceName是匿名内部类所继承的类名或实现的接口名。但匿名内部类不能同时实现一个接口和继承一个类，也不能实现多个接口。如果实现了一个接口，该类是Object类的直接子类，匿名类继承一个类或实现一个接口，不需要extends和implements关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8学习</title>
    <url>/2020/04/23/java8%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="1-Optional"><a href="#1-Optional" class="headerlink" title="1. Optional"></a>1. Optional</h2><p>Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException)。<br>本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空</p>
<h3 id="1-1-optional构造方式"><a href="#1-1-optional构造方式" class="headerlink" title="1.1. optional构造方式"></a>1.1. optional构造方式</h3><ul>
<li><p>Optional.of(T)</p>
<p>  该方式的入参不能为null，否则会有NPE，在确定入参不为空时使用该方式。</p>
</li>
<li><p>Optional.ofNullable(T)</p>
<p>  该方式的入参可以为null，当入参不确定为非null时使用。</p>
</li>
<li><p>Optional.empty()</p>
<p>  这种方式是返回一个空Optional，等效Optional.ofNullable(null)</p>
</li>
</ul>
<h3 id="1-2-如何正确的使用Optional"><a href="#1-2-如何正确的使用Optional" class="headerlink" title="1.2. 如何正确的使用Optional"></a>1.2. 如何正确的使用Optional</h3><ul>
<li><p>尽量避免使用的地方</p>
<ol>
<li><p>避免使用Optional.isPresent()来检查实例是否存在，因为这种方式和null != obj没有区别，这样用就没什么意义了。</p>
</li>
<li><p>避免使用Optional.get()方式来获取实例对象，因为使用前需要使用Optional.isPresent()来检查实例是否存在，否则会出现NPE问题。</p>
</li>
<li><p>避免使用Optional作为类或者实例的属性，而应该在返回值中用来包装返回实例对象。</p>
</li>
<li><p>避免使用Optional作为方法的参数，原因同3。</p>
</li>
</ol>
</li>
<li><p>正确使用方式</p>
<ol>
<li><p>实例对象存在则返回，否则提供默认值或者通过方法来设置返回值，即使用orElse/orElseGet方式：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存在则返回</span></span><br><span class="line">User king = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">Optional&lt;User&gt; userOpt = Optional.of(king);</span><br><span class="line">User user =  userOpt.orElse(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在提供默认值</span></span><br><span class="line">User user2 = <span class="keyword">null</span>;</span><br><span class="line">Optional&lt;User&gt; userOpt2 = Optional.ofNullable(user2);</span><br><span class="line">User user3 = userOpt2.orElse(unknown);</span><br><span class="line">System.out.println(user3.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过方法提供值</span></span><br><span class="line">User user4 = userOpt2.orElseGet(() -&gt; <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">&quot;DEFAULT&quot;</span>)); </span><br><span class="line">System.out.println(user4.getName())</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//不建议下面这种使用</span></span><br><span class="line"><span class="keyword">if</span>(userOpt.isPresent()) &#123;</span><br><span class="line">    System.out.println(userOpt.get().getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用ifPresent()来进行对象操作，存在则操作，否则不操作。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例存在则操作，否则不操作</span></span><br><span class="line">userOpt.ifPresent(u -&gt; System.out.println(u.getName()));</span><br><span class="line">userOpt2.ifPresent(u -&gt; System.out.println(u.getName()));</span><br></pre></td></tr></table></figure></li>
<li><p>使用map/flatMap来获取关联数据</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用map方法获取关联数据</span></span><br><span class="line">System.out.println(userOpt.map(u -&gt; u.getName()).orElse(<span class="string">&quot;Unknown&quot;</span>));</span><br><span class="line">System.out.println(userOpt2.map(u -&gt; u.getName()).orElse(<span class="string">&quot;Default&quot;</span>));</span><br><span class="line"><span class="comment">//使用flatMap方法获取关联数据</span></span><br><span class="line">List&lt;String&gt; interests = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">interests.add(<span class="string">&quot;a&quot;</span>);interests.add(<span class="string">&quot;b&quot;</span>);interests.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">user.setInterests(interests);</span><br><span class="line">List&lt;String&gt; interests2 = Optional.of(user)</span><br><span class="line">    .flatMap(u -&gt; Optional.ofNullable(u.getInterests()))</span><br><span class="line">    .orElse(Collections.emptyList());</span><br><span class="line">System.out.println(interests2.isEmpty());</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="1-3-Optional判断第三方接口"><a href="#1-3-Optional判断第三方接口" class="headerlink" title="1.3.Optional判断第三方接口"></a>1.3.Optional判断第三方接口</h3><p>使用java8的optional可以减少很多的NPE，再也不用当心别人的接口返回值问题了，也不用满屏的if（a != null）这种判断，下面是使用过程中遇到的问题以及如何使用Optional解决。</p>
<h4 id="1-3-1-接口返回参数问题"><a href="#1-3-1-接口返回参数问题" class="headerlink" title="1.3.1. 接口返回参数问题"></a>1.3.1. 接口返回参数问题</h4><ol>
<li>在微服务中使用feign调用其他接口，总担心别人返回的参数是否符合标准</li>
<li>参数符合标准后，然后再进行数据判断，先判断是否code为200，然后判断数据存不存在，这样冗余的代码就很多</li>
</ol>
<p>这是我们期望的返回格式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;调用成功!&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;data&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟接口调用方法</span></span><br><span class="line">Map&lt;String,Object&gt; map = serviceImpl.queryList();</span><br><span class="line"><span class="comment">//即使map为空也能正常返回，配合map直接映射数据值</span></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(map).map(r-&gt; r.get(<span class="string">&quot;data&quot;</span>)).orElseGet(ArrayList:: <span class="keyword">new</span>)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//JSONObject 判断是否返回成功，如果成功返回200， 不成功返回400   </span></span><br><span class="line">JSONObject jsonObject = service.updateDate();</span><br><span class="line">Optional.ofNullable(jsonObject).map(r-&gt;r.getInteger(<span class="string">&quot;code&quot;</span>)).orElse(<span class="number">400</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-避免判断风暴"><a href="#1-3-2-避免判断风暴" class="headerlink" title="1.3.2. 避免判断风暴"></a>1.3.2. 避免判断风暴</h4><p>对象层层嵌套，为了逻辑严谨必须要进行空判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于一个对象里面嵌套对象，那么需要层层去判断非空</span></span><br><span class="line">School school = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(school != <span class="keyword">null</span>)&#123;</span><br><span class="line">    Clazz clazz = school.getClazz();</span><br><span class="line">    <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Student student = clazz.getStudent();</span><br><span class="line">        <span class="keyword">if</span>(student != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String name = student.getName();</span><br><span class="line">            <span class="keyword">if</span>(name == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(name))&#123;</span><br><span class="line">                name = <span class="string">&quot;学生的姓名为空&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Optional后</span></span><br><span class="line"> String name = Optional.ofNullable(school)</span><br><span class="line">                .map(School::getClazz)</span><br><span class="line">                .map(Clazz::getStudent)</span><br><span class="line">                .map(Student::getName)</span><br><span class="line">                .orElse(<span class="string">&quot;学生的姓名为空&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-Stream"><a href="#2-Stream" class="headerlink" title="2. Stream"></a>2. Stream</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出某一个字段等于某个值的那一条数据</span></span><br><span class="line">JaponicaRiceCheck1 streamCheck = listItemRice.stream()</span><br><span class="line">.filter(o -&gt; o.getSYS_PARENTID().equals(check.getSYS_ID())).findAny().orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>锁优化</title>
    <url>/2021/07/23/lock01/</url>
    <content><![CDATA[<h2 id="1-优化思路以及方法"><a href="#1-优化思路以及方法" class="headerlink" title="1. 优化思路以及方法"></a>1. 优化思路以及方法</h2><ul>
<li>减少锁持有时间</li>
<li>减小锁粒度</li>
<li>锁分离</li>
<li>锁粗化</li>
<li>锁消除</li>
</ul>
<h3 id="1-1-减少锁持有时间"><a href="#1-1-减少锁持有时间" class="headerlink" title="1.1 减少锁持有时间"></a>1.1 减少锁持有时间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    mutextMethod();</span><br><span class="line">    othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上述代码，在进入方法前就要得到锁，其他线程就要在外面等待。</p>
<p>分析：锁里面的资源在同一时间只允许一个线程执行，我们不仅要减少其他线程等待的时间，也要尽力减少线程在锁里面的执行时间，所以，尽量只有在有线程安全要求的程序代码上加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        metextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-减小锁粒度"><a href="#1-2-减小锁粒度" class="headerlink" title="1.2 减小锁粒度"></a>1.2 减小锁粒度</h3><p>将大对象（这个对象可能会被很多线程访问）拆成小对象，大大增加并行度。</p>
<p>降低锁竞争，那么偏向锁、轻量级锁成功率才会提高。</p>
<p>最最典型的减小锁粒度的案例就是ConcurrentHashMap。在HashMap的基础上进行优化，使用了cas与synchronized来确保安全性，在保证安全性的基础上为了充分利用线程资源，更是巧妙的设计了多线程同扩容的模式。</p>
<h3 id="1-3-锁分离"><a href="#1-3-锁分离" class="headerlink" title="1.3 锁分离"></a>1.3 锁分离</h3><p>最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁。这样读读不互斥，读写互斥，写写互斥。既保证了线程安全，又提高了性能。</p>
<p>分析：读写分离这种思想可以延伸到我们其他的设计中，只要操作上互不影响，那锁就可以进行分离，比如：LinkedBlockingQueue</p>
<img src="..\images/read_writer_Lock1.png" alt="read_writer_Lock1" style="zoom: 67%;">

<p>从头部获取数据，从尾部放入数据，使用两把锁。</p>
<h3 id="1-4-锁粗化"><a href="#1-4-锁粗化" class="headerlink" title="1.4 锁粗化"></a>1.4 锁粗化</h3><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁，只有这样，等待在这个锁上的其他线程才能尽早的获取资源执行任务；但是凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>&#123;</span><br><span class="line">    	<span class="comment">//dow sth.</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//....做其他不需要同步的工作，但能很快执行完毕</span></span><br><span class="line">    <span class="keyword">synchronized</span>&#123;</span><br><span class="line">        <span class="comment">//do sth.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况，根据锁粗化的思想，应该合并：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//整合成一次锁请求,前提时中间哪些不需要同步的工作很快就执行完成</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//do sth.</span></span><br><span class="line">        <span class="comment">//....做其他不需要同步的工作，但能很快执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再举一个极端的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; circle; i++)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个循环内不同得获得锁。虽然JDK内部会对这个代码做些优化，但是还不如直接写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; circle; i++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果有需求说，这样的循环太久，需要给其他线程不要等待太久，那只能写成上面那种。如果没有这样类似的需求，还是直接写成后者那种比较好。<br><strong>分析</strong>: 锁粗化是JVM默认启动的一种机制，锁粗化针对的是对连续的区域进行分段加锁这种场景，JVM会自发进行优化。但作为开发者而言在满足业务的情况下，应该减少锁的使用。</p>
<h3 id="1-5-锁消除"><a href="#1-5-锁消除" class="headerlink" title="1.5 锁消除"></a>1.5 锁消除</h3><p>锁消除是在编译器级别的事情。在即时编译器(JIT)时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。也许你会觉得奇怪，既然有些对象不可能被多线程访问，那为什么要加锁呢？写代码时直接不加锁不就好了。<br>但是有时，这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterrruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20000</span>; i++)&#123;</span><br><span class="line">        createStringBuffer(<span class="string">&quot;JVM&quot;</span>,<span class="string">&quot;asdfasdfasdf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> bufferCost = System.currentTimeTimeMillis() - start;</span><br><span class="line">    System.out.println(<span class="string">&quot;createStringBuffer:&quot;</span>+bufferCost+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的StringBuffer.append是一个同步操作，但是StringBuffer却是一个局部变量，并且方法也并没有把StringBuffer返回，所以不可能会有多线程去访问它。那么此时StringBuffer中的同步操作就是没有意义的。<br>开启锁消除是在JVM参数上设置的，当然需要在server模式下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure>

<p>并且要开启逃逸分析。 逃逸分析的作用呢，就是看看变量是否有可能逃出作用域的范围。<br>比如上述的StringBuffer，上述代码中craeteStringBuffer的返回是一个String，所以这个局部变量StringBuffer在其他地方都不会被使用。如果将craeteStringBuffer改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个 StringBuffer被返回后，是有可能被任何其他地方所使用的（譬如被主函数将返回结果put进map啊等等）。那么JVM的逃逸分析可以分析出，这个局部变量 StringBuffer逃出了它的作用域。<br>所以基于逃逸分析，JVM可以判断，如果这个局部变量StringBuffer并没有逃出它的作用域，那么可以确定这个StringBuffer并不会被多线程所访问，那么就可以把这些多余的锁给去掉来提高性能。<br>当JVM参数为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">createStringBuffer: 302ms</span><br></pre></td></tr></table></figure>

<p>JVM参数为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:-EliminateLocks</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">createStringBuffer: 660ms</span><br></pre></td></tr></table></figure>

<p>显然，锁消除的效果还是很明显的。</p>
]]></content>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>MVCC多版本并发控制</title>
    <url>/2021/08/14/mvcc/</url>
    <content><![CDATA[<h3 id="1-MVCC"><a href="#1-MVCC" class="headerlink" title="1. MVCC"></a>1. MVCC</h3><p>全称Multi-Version Concurrency Control即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中是心啊事务内存。<br>MVCC在mysql Innodb中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使读写冲突时，也能做到不加锁，非阻塞并发读</p>
<h3 id="2-当前读和快照读"><a href="#2-当前读和快照读" class="headerlink" title="2. 当前读和快照读"></a>2. 当前读和快照读</h3><ul>
<li><p>当前读</p>
<p>  像select lock in share mode（共享锁），select for update， update, insert,delete(排他锁)这些操作都是一种当前读；<strong>当前读就是读取记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</strong>。</p>
</li>
<li><p>快照读</p>
<p>  像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别（串行级别快照读会变成当前读）；快照读的实现是基于多版本并发控制（即MVCC）；可以任务MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；<br>  既然是基于多版本，即快照读可能读到的并不一定是最新版本的数据，有可能是之前的历史版本</p>
</li>
</ul>
<p><strong>MVCC就是为了实现读（快照读）-写冲突不加锁，当前读实际上是一种加锁的操作，是悲观锁的实现。</strong></p>
<hr>
<h3 id="3-当前读、快照读和MVCC的关系"><a href="#3-当前读、快照读和MVCC的关系" class="headerlink" title="3. 当前读、快照读和MVCC的关系"></a>3. 当前读、快照读和MVCC的关系</h3><p>MVCC多版本并发控制指的是”维持一个数据的多个版本，使得读写操作没有冲突”；<br>Mysql通过快照读的方式去实现MVCC理想模型的其中一个具体非阻塞读功能，相对而言，当前读就是悲观锁的具体功能实现</p>
<p>MVCC模型在Mysql中具体实现有3个隐式字段：undo日志、Read View等去完成的</p>
<h3 id="4-MVCC的作用与好处"><a href="#4-MVCC的作用与好处" class="headerlink" title="4. MVCC的作用与好处"></a>4. MVCC的作用与好处</h3><p>数据库并发场景分为以下三种：</p>
<ul>
<li>读-读：没有问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，（脏读、幻读、不可重复读）</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题</li>
</ul>
<p><strong>MVCC带来的好处：</strong></p>
<p>MVCC是一种用来解决读-写冲突的无所并发控制（在MVCC提出之前采用的是采用<strong>悲观锁</strong>），也就是事务分配增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务前的数据库快照，主要解决以下问题：</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作是不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；</li>
<li>解决脏读、幻读、不可重复读等事务隔离性问题，但不能解决更新丢失问题</li>
</ul>
<p><strong>MVCC组合方法</strong></p>
<ul>
<li>MVCC + 悲观锁： MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li>MVCC + 乐观锁： MVCC解决读写冲突，乐观锁解决写写冲突，这种方式可能最大程度的提高数据库并发性能，并解决读写冲突和写写冲突导致的问题</li>
</ul>
<h3 id="5-MVCC的实现原理"><a href="#5-MVCC的实现原理" class="headerlink" title="5. MVCC的实现原理"></a>5. MVCC的实现原理</h3><p>实现原理主要是依赖记录中的 3个隐式字段、undo日志 、ReadView 来实现的</p>
<p>在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程<br>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。</p>
<h4 id="5-1-版本链"><a href="#5-1-版本链" class="headerlink" title="5.1 版本链"></a>5.1 版本链</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">#触发分配TRX_ID</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_role;</span><br><span class="line">#指定TRX_MYSQL_THREAD_ID<span class="operator">=</span>当前CONNECTION_ID,表示查询当前连接</span><br><span class="line"><span class="keyword">select</span> TRX_ID, ROLL_PTR, ROW_ID  <span class="keyword">from</span> INFORMATION_SCHEMA.INNODB_TRX <span class="keyword">where</span> TRX_MYSQL_THREAD_ID <span class="operator">=</span> CONNECTION_ID();</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>
<ul>
<li><p>TRX_ID</p>
<p>6byte，这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id</p>
</li>
<li><p>roll_pointer</p>
<p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
</li>
<li><p>ROW_ID</p>
<p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</p>
</li>
<li><p>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了<br><img src="/2021/08/14/mvcc/02.png"></p>
</li>
</ul>
<p>比如现在有个事务id是60的执行的这条记录的修改语句</p>
<p><img src="/2021/08/14/mvcc/03.png"></p>
<p>此时在undo日志中就存在版本链<br><img src="/2021/08/14/mvcc/04.png"></p>
<h4 id="5-2-ReadView"><a href="#5-2-ReadView" class="headerlink" title="5.2 ReadView"></a>5.2 ReadView</h4><p>已提交读和可重复读的区别就在于它们生成ReadView的策略不同<br>ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。</p>
<ul>
<li>如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</li>
<li>如果你要访问的记录版本的事务id为90,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。</li>
<li>如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。<br>这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mvcc</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/2021/08/20/mysql-index/</url>
    <content><![CDATA[<p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。<br>索引分单列索引和组合索引。</p>
<ul>
<li>单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。 </li>
<li>组合索引，即一个索引包含多个列。</li>
</ul>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。<br>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。<br>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：<br>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。<br>建立索引会占用磁盘空间的索引文件。</p>
<h2 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h2><ul>
<li>创建索引  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">on</span> table_name (column_name )</span><br></pre></td></tr></table></figure></li>
<li>添加索引（修改表结构）  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表结构已经存在了，然后使用alter修改表结构添加索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name  <span class="keyword">add</span> INDEX indexName(column_name )</span><br></pre></td></tr></table></figure></li>
<li>创建表指定  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   </span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">    INDEX [indexName] (username(length))  </span><br><span class="line">); </span><br></pre></td></tr></table></figure></li>
<li>删除索引  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index [indexName] <span class="keyword">on</span>  table_name </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2. 唯一索引"></a>2. 唯一索引</h2><p>他和普通索引类似，不同的是：索引列的值必须唯一，但允许有控制。如果是组合索引，则列值的组合必须唯一。</p>
<ul>
<li>创建索引  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX indexName <span class="keyword">ON</span> table_name (column_name (length ))</span><br></pre></td></tr></table></figure></li>
<li>修改表结构  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> mytable <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [indexName] (column_name(length))</span><br></pre></td></tr></table></figure></li>
<li>创建表的时候指定  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   </span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">    <span class="keyword">UNIQUE</span> [indexName] (username(length))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="3-组合索引"><a href="#3-组合索引" class="headerlink" title="3.组合索引"></a>3.组合索引</h2></li>
<li>修改表结构指定索引  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX indexName (column_name1 , column_name2,...)</span><br></pre></td></tr></table></figure></li>
<li>创建表的时候指定  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   </span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">    KEY [indexName] (column_name1 , column_name2,...)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-1-组合索引查询问题"><a href="#3-1-组合索引查询问题" class="headerlink" title="3.1 组合索引查询问题"></a>3.1 组合索引查询问题</h3></li>
</ul>
<p><strong>问题描述：</strong>在mysql中有张表test_a，有3个字段id,name,num；对这三个字段建立组合索引，那么查询时使用其中某两个或者一个作为查询条件，是否还会走索引<br><img src="/2021/08/20/mysql-index/01.png" alt="表结构"><br>根据查询字段的位置不同来决定，如查询<strong>id</strong>、<strong>id,num</strong>、<strong>id,num,name</strong>、 <strong>id, name</strong> 都可以走索引的，其他条件的查询不能走索引。</p>
<p><strong>组合索引 有“最左前缀”原则。就是只从最左面的开始组合，并不是所有只要含有这三列存在的字段的查询都会用到该组合索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加组合索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_a <span class="keyword">ADD</span> INDEX <span class="string">&#x27;lianhe&#x27;</span>(id, num, name)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用三个字段id, num, name查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只要三个条件都有，可以随意变换位置，结果都会走索引</span></span><br><span class="line"><span class="comment">-- 优化器会将条件顺序优化成上面三种情况后执行</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> num<span class="operator">=</span><span class="string">&#x27;001&#x27;</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;1#&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/20/mysql-index/02.png" alt="使用三个字段id, num, name查询"><br>从执行结果上可以看到是从走索引进行查询的</p>
</li>
<li><p>使用num, name 查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;1#&#x27;</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> num<span class="operator">=</span><span class="string">&#x27;001&#x27;</span> </span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/20/mysql-index/03.png" alt="使用id, name 查询"></p>
</li>
<li><p>使用id, name或者id, num 查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只要包括id，可以随意变换位置，结果都会走索引</span></span><br><span class="line"><span class="comment">-- 优化器会将条件顺序优化成上面三种情况后执行</span></span><br><span class="line"><span class="comment">--如果只有两个字段，只有id条件命中，num或者name 条件不走联合索引。</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;1#&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/20/mysql-index/02.png" alt="使用id, name 查询"></p>
</li>
</ol>
<p>需要避免索引失效的情况，如：LIKE %xxx，或者条件中使用函数等。<br>4. 使用id查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/20/mysql-index/02.png" alt="使用id查询"></p>
<ol start="5">
<li>使用name或者num查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;1#&#x27;</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_a <span class="keyword">WHERE</span> num <span class="operator">=</span> <span class="string">&#x27;001&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-2-创建组合索引选择规则"><a href="#3-2-创建组合索引选择规则" class="headerlink" title="3.2 创建组合索引选择规则"></a>3.2 创建组合索引选择规则</h3><ul>
<li>经常用的列优先（最左匹配原则）</li>
<li>离散度高的列优先（离散度高原则）</li>
<li>宽度小的列优先（最少空间原则）</li>
</ul>
<h2 id="4-使用alter命令添加索引"><a href="#4-使用alter命令添加索引" class="headerlink" title="4.使用alter命令添加索引"></a>4.使用alter命令添加索引</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (column_list): </span><br><span class="line">    </span><br><span class="line"><span class="comment">--  这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name (column_list):</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加普通索引，索引值可出现多次。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> INDEX index_name (column_list):</span><br><span class="line"></span><br><span class="line"><span class="comment">--该语句指定了索引为 FULLTEXT ，用于全文索引。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> FULLTEXT index_name (column_list):</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务</title>
    <url>/2021/07/23/mysql-transcation/</url>
    <content><![CDATA[<h2 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h2><p>事务是数据管理系统DBMS执行过程中的一个<strong>逻辑单位</strong>，有一个有限的数据库<strong>操作序列</strong>构成</p>
<h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><ol>
<li> 原子性atomicity：依赖undo log做到全部失败</li>
<li> 隔离性isolation：实现方式LBCC 和 MVCC</li>
<li> 持久性durability ：实现方式redo log和double write</li>
<li> 一致性consistency：通过上面的三种方式实现</li>
</ol>
<p>数据恢复：</p>
<ul>
<li>  redo log 崩溃恢复</li>
<li>  双写缓冲（double write）</li>
</ul>
<p>Mysql中insert、delete、update 自带事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> veriables <span class="keyword">like</span> ‘autocommit’;</span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line">update xxx <span class="keyword">where</span> <span class="keyword">set</span> xx <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>结束事务两种方式：rollback     commit</p>
<h2 id="事务并发的三大问题"><a href="#事务并发的三大问题" class="headerlink" title="事务并发的三大问题"></a>事务并发的三大问题</h2><p>数据并发的三大问题其实都是数据库读一致性问题，必须有数据库提供一定的事务隔离机制来解决。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202210510525.png" alt="image-20200727224117281"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202210235089.png" alt="image-20200727224117281"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202210357906.png" alt="image-20200727224117281"></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt</a><br><img src="/2021/07/23/mysql-transcation/image-20201202210817094.png" alt="image-20200727224117281"><br><img src="/2021/07/23/mysql-transcation/image-20201202211406282.png" alt="image-20200727224117281"></p>
<p><img src="/2021/07/23/mysql-transcation/image-20201202211752764.png" alt="image-20201202211752764"></p>
<h3 id="MVCC思想"><a href="#MVCC思想" class="headerlink" title="MVCC思想"></a>MVCC思想</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202212103393.png" alt="image-20201202212103393"></p>
<h4 id="Read-View（一致性试图）"><a href="#Read-View（一致性试图）" class="headerlink" title="Read View（一致性试图）"></a>Read View（一致性试图）</h4><p>存储内容</p>
<p><img src="/2021/07/23/mysql-transcation/image-20201202213520136.png" alt="image-20201202213520136"></p>
<h4 id="Read-View判断规则"><a href="#Read-View判断规则" class="headerlink" title="Read View判断规则"></a>Read View判断规则</h4><p><img src="/2021/07/23/mysql-transcation/image-20201202213757692.png" alt="image-20201202213757692"></p>
<h4 id="RC与RR-read-View-的区别"><a href="#RC与RR-read-View-的区别" class="headerlink" title="RC与RR read View 的区别"></a>RC与RR read View 的区别</h4><p><img src="/2021/07/23/mysql-transcation/image-20201202214418001.png" alt="image-20201202214418001"></p>
<p>所以RC解决不了脏读的问题</p>
<h1 id="Mysql-InnoDb所得基本类型"><a href="#Mysql-InnoDb所得基本类型" class="headerlink" title="Mysql InnoDb所得基本类型"></a>Mysql InnoDb所得基本类型</h1><p>InnoDB支持行锁</p>
<p>MyiSAM支持行锁</p>
<p>表锁和行锁的区别</p>
<ul>
<li>  锁力度：表锁 &gt; 行锁</li>
<li>  加锁效率：表锁 &gt; 行锁</li>
<li>  冲突概率：表锁 &gt; 行锁</li>
<li>  并发性能：表锁 &lt; 行锁</li>
</ul>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p><img src="/2021/07/23/mysql-transcation/image-20201202214957559.png" alt="image-20201202214957559"></p>
<p>一个事务能够给一张表加上锁的前提是：没有其他任何一个事务锁定了这张表的任意一行数据。如果没有意向锁的话，那么加表锁需要扫描表中的每行数据，大大的浪费时间；</p>
<p>如果在添加行锁的时候，会在表上添加意向锁，那么在添加表锁的时候就不需要去扫描所有表数据了，只需要看下表上是否由意向锁就可；</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><h3 id="共享锁shared-locks"><a href="#共享锁shared-locks" class="headerlink" title="共享锁shared locks"></a>共享锁shared locks</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202215350319.png" alt="image-20201202215350319"></p>
<h3 id="排它锁Exclusive-locks"><a href="#排它锁Exclusive-locks" class="headerlink" title="排它锁Exclusive locks"></a>排它锁Exclusive locks</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202215717524.png" alt="image-20201202215717524"></p>
<h3 id="Innodb行锁锁定的是什么"><a href="#Innodb行锁锁定的是什么" class="headerlink" title="Innodb行锁锁定的是什么"></a>Innodb行锁锁定的是什么</h3><p>锁定的是index索引，如果表中没有索引，那么Innodb会把隐藏列DB_ROW_ID当作聚集索引</p>
<p>加锁一定要加上条件，不然会锁表</p>
<p><img src="/2021/07/23/mysql-transcation/image-20201202222250939.png" alt="image-20201202222250939"></p>
<h3 id="记录锁Rcord-Lock-锁定记录"><a href="#记录锁Rcord-Lock-锁定记录" class="headerlink" title="记录锁Rcord Lock 锁定记录"></a>记录锁Rcord Lock 锁定记录</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202222823984.png" alt="image-20201202222823984"></p>
<h3 id="间隙锁Gap-Lock-锁定范围"><a href="#间隙锁Gap-Lock-锁定范围" class="headerlink" title="间隙锁Gap Lock 锁定范围"></a>间隙锁Gap Lock 锁定范围</h3><p>专门用于阻塞插入，间隙锁如果没有命中的话，会锁定最后一个值到正无穷，那么在最后一个值和正无穷之间的插入都不能成功。</p>
<p><img src="/2021/07/23/mysql-transcation/image-20201202222914087.png" alt="image-20201202222914087"></p>
<h3 id="临健锁Next-key-Lock-：锁定范围加记录"><a href="#临健锁Next-key-Lock-：锁定范围加记录" class="headerlink" title="临健锁Next-key Lock ：锁定范围加记录"></a>临健锁Next-key Lock ：锁定范围加记录</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202223655445.png" alt="image-20201202223655445"></p>
<p><strong>为了解决幻读的问题</strong></p>
<h3 id="事务隔离级别的实现"><a href="#事务隔离级别的实现" class="headerlink" title="事务隔离级别的实现"></a>事务隔离级别的实现</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202224136052.png" alt="image-20201202224136052"></p>
<h3 id="事务隔离级别的选择"><a href="#事务隔离级别的选择" class="headerlink" title="事务隔离级别的选择"></a>事务隔离级别的选择</h3><p><img src="/2021/07/23/mysql-transcation/image-20201202224412832.png" alt="image-20201202224412832"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql知识总结</title>
    <url>/2021/07/23/mysql/</url>
    <content><![CDATA[<h1 id="mysql-初识"><a href="#mysql-初识" class="headerlink" title="mysql 初识"></a>mysql 初识</h1><h2 id="1-版本历史"><a href="#1-版本历史" class="headerlink" title="1. 版本历史"></a>1. 版本历史</h2><ul>
<li>  1996年 mysql.10发布</li>
<li>  1996年10月3.11.1发布</li>
<li>  2000年ISAM升级成MyISAM引擎，mysql开源</li>
<li>  2003年 Mysql4.0发布集成InnoDB存储引擎</li>
<li>  2005年 MySQL 5.0版本发布，提供了试图，存储过程等功能</li>
<li>  2010年MySQL5.5发布，InnoDB成为默认的存储引擎</li>
<li>  2016年发布8.0.0版本</li>
</ul>
<h2 id="2-流行分支"><a href="#2-流行分支" class="headerlink" title="2. 流行分支"></a>2. 流行分支</h2><ul>
<li>  Maria DB</li>
<li>  Percona Server</li>
</ul>
<h2 id="3-SQL-执行流程"><a href="#3-SQL-执行流程" class="headerlink" title="3. SQL 执行流程"></a>3. SQL 执行流程</h2><h3 id="通信类型"><a href="#通信类型" class="headerlink" title="通信类型"></a>通信类型</h3><ul>
<li>  同步</li>
<li>  异步</li>
</ul>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ul>
<li>  长连接</li>
<li>  短连接</li>
</ul>
<h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><ul>
<li><p>非交互式超时时间，如JDBC程序，单位s</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;wait_timeout&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>交互式超时间，如数据库工具</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> variables <span class="keyword">LIKE</span> <span class="string">&#x27;interactive_timeout&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看连接"><a href="#查看连接" class="headerlink" title="查看连接"></a>查看连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Thread%&#x27;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">连接名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Threads_cached</td>
<td align="center">缓存中的线程</td>
</tr>
<tr>
<td align="center">Threads_connected</td>
<td align="center">连接中线程</td>
</tr>
<tr>
<td align="center">Threads_created</td>
<td align="center">创建过的线程</td>
</tr>
<tr>
<td align="center">Threads_running</td>
<td align="center">正在执行的线程</td>
</tr>
</tbody></table>
<h4 id="查看所有的线程"><a href="#查看所有的线程" class="headerlink" title="查看所有的线程"></a>查看所有的线程</h4><p>如果是root权限，可以看到所有用户发起的线程，否则只能看到自己的线程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/23/mysql/image-20200727224117281.png" alt="image-20200727224117281"></p>
<ul>
<li>  id ：一个表示，kill一个语句的时候可以使用</li>
<li>  user：显示当前用户，如果不是root，这个命令就只显示你权限范围内的sql语句</li>
<li>  host：显示这个语句是从哪个ip的端口上发出的，可以用来追踪出问题语句的用户</li>
<li>  db：显示这个进程目前连接的是哪个数据库</li>
<li>  commmand：显示当年连接的执行命令，一般分为休眠slee、查询query、连接connect</li>
<li>  time：此状态持续的时间，单位是秒</li>
<li>  state： 显示使用当年连接的sql语句状态，state只是语句执行中的某一个状态，如查询：需要经过copying to tmp table、sorting result、sending data等转台才可以完成</li>
<li>  info：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全</li>
</ul>
<h4 id="查看最大连接数"><a href="#查看最大连接数" class="headerlink" title="查看最大连接数"></a>查看最大连接数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">LIKE</span> <span class="string">&#x27;max_connections&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>一般默认是<span class="number">151</span>，最大可以是<span class="number">2</span>的<span class="number">14</span>次方</span><br></pre></td></tr></table></figure>
<h4 id="mysql变量级别"><a href="#mysql变量级别" class="headerlink" title="mysql变量级别"></a>mysql变量级别</h4><ul>
<li><p>global全局</p>
  <figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在mysql中修改全局变量global有两种方法：</span><br><span class="line">1. 修改my.ini配置文件（永久有效）</span><br><span class="line">2. 在不修改配置文件的基础上，使用关键字global设置全局变量</span><br><span class="line">   set global autocommit = 1;将autocommit变量的值设置为ON，需要注意的是此方法对global全局变量的设计进对于新开启的会话有效，对已开启的会话无效，同理，如果修改回哈session变量，可以使用session关键字，如set session autocommit = 1；这个仅对本session的变量配置有效，对其他的session无效；（在MySQL服务重启之后，数据库的配置重新按照my.ini文件 初始化，global和session 的配置都会失效）</span><br></pre></td></tr></table></figure></li>
<li><p>  session当前会话</p>
</li>
</ul>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><ul>
<li>  Unix Socket</li>
<li>  TCP/IP</li>
<li>  Named Pipes命名管道</li>
<li>  Share Memory共享内存</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li>  单工</li>
<li>  半双工</li>
<li>  全双工</li>
</ul>
<p><img src="/2021/07/23/mysql/image-20200727231112059.png" alt="image-20200727231112059"></p>
<h3 id="MySQL-缓存"><a href="#MySQL-缓存" class="headerlink" title="MySQL 缓存"></a>MySQL 缓存</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache%&#x27;</span></span><br><span class="line">#默认关闭，是因为mysql要保证两次执行的<span class="keyword">sql</span>完全一致，连空格，大小写都一致，而且当数据表中的任何一条数据发生变化，整个缓存会失效；</span><br></pre></td></tr></table></figure>

<p>#2. 删除数据</p>
<h2 id="1-数据删除方式"><a href="#1-数据删除方式" class="headerlink" title="1. 数据删除方式"></a>1. 数据删除方式</h2><ul>
<li>DELETE</li>
<li>Truncate</li>
<li>Drop</li>
</ul>
<h2 id="2-执行速度"><a href="#2-执行速度" class="headerlink" title="2. 执行速度"></a>2. 执行速度</h2><p>drop &gt; truncate &gt; delete</p>
<h3 id="2-1-DELETE"><a href="#2-1-DELETE" class="headerlink" title="2.1 DELETE"></a>2.1 DELETE</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> XXX</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DELETE 数据数据库DML操作语言，只删除数据不删除表的结构，会走事务，执行时会触发trigger</p>
</li>
<li><p>在InnoDB中，delete其实并不会真的把数据删除，mysqL实际上只是给删除的数据打个标记为删除，因此delete删除表中的数据，表文件在磁盘所占的控件不会变小，存储控件不会被释放，只是把删除的数据设置为不可见。虽然未释放磁盘控件，但是下次插入数据的时候，仍然可以重用这部分空间（重用-&gt;覆盖）</p>
</li>
<li><p>delete执行时，会先把所删除数据缓存到rollback segement中，事务commit之后生效</p>
</li>
<li><p><strong>delete from  table_name</strong> 删除表的全部数据对于MyISAM会释放磁盘控件，Innodb不会释放磁盘空间</p>
</li>
<li><p>对于<strong>DELETE from table_name where xxx</strong>带条件的删除，不管是Innodb还是MyISAM都不会释放磁盘控件</p>
</li>
<li><p>delete 操作以后使用<strong>optimize table  table_name</strong>会里级释放磁盘空间（不管是Innodb还是MyISAM）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看表占用磁盘空间大小</span></span><br><span class="line"><span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(DATA_LENGTH<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;M&#x27;</span>) <span class="keyword">as</span> table_size</span><br><span class="line"><span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;demo_db&#x27;</span> <span class="keyword">AND</span> table_name<span class="operator">=</span><span class="string">&#x27;demo_table&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行空间优化语句，以及执行后的表size变化</span></span><br><span class="line">optimize <span class="keyword">table</span> demo_table</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>delete 操作时一行一行执行删除的，并且同时将该行的删除操作日志记录在redo和undo表空间中以便进行回滚（rollback）和重做操作</strong>，生成大量日志也会占用磁盘空间</li>
</ul>
<h3 id="2-2-Truncate"><a href="#2-2-Truncate" class="headerlink" title="2.2 Truncate"></a>2.2 Truncate</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--删除表数据， 不带where条件</span></span><br><span class="line"><span class="comment">--与不带where的delete ：只删除数据，而不删除表的结构	</span></span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Truncate数据数据库DDL定义语言，不走事务，原数据不放到rollback segement中，操作不触发trigger</strong>，执行后里级生效，无法找回；</p>
</li>
<li><p><strong>truncate table table_name里级释放磁盘空间不管是Innodb 和MyISAM</strong>；truncate table其实有点类似余drop table然后create，只不过这个crate table的过程做了优化，比如表结构文件之前已经有了等，所以速度上应该是接近drop table的速度</p>
</li>
<li><p>truncate 能快速清空一个表，并且重置auto_increment的值</p>
<p>​    但是对于不同的类型存储引擎需要注意的地方是：</p>
<ul>
<li><strong>对于MyISAM</strong>：truncate会重置auto_increment（自增序列）的值为1，而delete后表仍然保持auto_increment。</li>
<li><strong>对于Innodb</strong>：truncate会重置auto_increment（自增序列）的值为1， 而delete后表仍然保持auto_increment。但是在做delete整个表之后重启mysql的话，而重启后的auto_increment会被置为1</li>
</ul>
<p>也就是说，Innodb的表本身是无法持久保存auto_increment。delete表之后auto_increment仍然保存在内存，但是重启后就丢失了，只能从1开始，实质上重启后的auto_increment会从SELETE 1+MAX(ai_col) FROM t开始</p>
</li>
<li><p>小心使用 truncate，尤其没有备份的时候，如果误删除线上的表，记得及时联系中国民航，订票电话：400-806-9553</p>
</li>
</ul>
<h3 id="2-3-Drop"><a href="#2-3-Drop" class="headerlink" title="2.3 Drop"></a>2.3 Drop</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表结构以及表数据</span></span><br><span class="line"><span class="keyword">Drop</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>drop：属于数据库DDL定义语言，同Truncate；</strong></p>
<p><strong>执行后立即生效，无法找回！ 执行后立即生效，无法找回！ 执行后立即生效，无法找回！</strong></p>
</li>
<li><p>**drop table table_name 立刻释放磁盘空间 ，不管是 InnoDB 和 MyISAM; **drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index); 依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</p>
</li>
<li><p>小心使用 drop ，要删表跑路的兄弟，请在订票成功后在执行操作！订票电话：400-806-9553</p>
</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库锁</title>
    <url>/2021/07/24/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
    <content><![CDATA[<p>当数据库有事物的时候，可能会产生数据的不一致，这时就需要一些机制来保证访问的次序，这就是锁的机制；<br><strong>锁的作用</strong>：用于挂你对共享资源的并发访问，保证数据库的完整性和一致性。<br>##1. 不同引擎的锁以及锁分类<br><strong>Mysql数据库中，InnoDB支持表、行级锁，而MyISAM支持表级锁</strong><br><br><br>Mysql大致可以归纳为以下3种锁：</p>
<ul>
<li>表级锁：开销小，加锁块，不会出现死锁，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁，发生锁冲突的概率最低，并发度最高。</li>
<li>页面锁：开销和加锁的时间介于表级锁和行级锁之间，会出现死锁，锁粒度介于两者之间；并发度一般，一次锁定相邻一组记录</li>
</ul>
<p>Mysql表级锁两种模式: <strong>表共享锁（Table Read Lock）和 表独占写锁（Table Write Lock）</strong>，表现如下：</p>
<ul>
<li>对一个表的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</li>
<li>对MyISAM的写操作，则会则色其他用户对同一表的读和写操作；</li>
<li>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。<br>当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待。</li>
</ul>
<p>##2.加表级锁<br>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。<br>给MyISAM表显式加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表order_detail，其中记录有订单每一产品的金额小计subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx安装</title>
    <url>/2021/07/23/nginx/</url>
    <content><![CDATA[<h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><ul>
<li>2000年地洞，c语言编写</li>
<li>2004年开源</li>
<li>2011年成立商业公司</li>
<li>2013 发布商业版本Nginx plus</li>
<li>2019.5月F5 networks收购nginx</li>
<li>2019.12被Rambler集团起诉</li>
</ul>
<p>##Nginx与其他web服务器对比</p>
<ol>
<li>Nginx与A pace HTTP server project区别</li>
<li>Nginx 和tomcat区别<ul>
<li>Nginx是HTTP Server，主要是用于访问一些静态资源，可以用做代理服务器</li>
<li>tomcat是Application Server应用服务器</li>
</ul>
</li>
<li>HTTP Server 和Application Server区别与联系</li>
</ol>
<h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><ol>
<li><p>安装nginx前首先要确认系统中是否安装了gcc 、pcre-devel、zlib-devel、openssl-devel</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、rpm包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用 rpm -qa | grep <span class="string">&quot;软件或者包的名字&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">2、以deb包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 dpkg -l | grep <span class="string">&quot;软件或者包的名字&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">3、yum方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 yum list installed | grep <span class="string">&quot;软件名或者包名&quot;</span></span></span><br><span class="line">yum list installed | grep &quot;gcc&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/23/nginx/image-20201210100736952.png" alt="image-20201210103251475"></p>
</li>
<li><p>安装依赖包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure></li>
<li><p>下载并解压安装包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//创建nginx存放文件夹</span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">下载tar包</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.13.7.tar.gz</span><br><span class="line">tar -xvf nginx-1.13.7.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nginx-1.13.7</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li><p>测试是否安装成功</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -t</span><br></pre></td></tr></table></figure>

 <img src="/2021/07/23/nginx/_posts/2021/07/nginx/image-20201210101238462.png" alt="image-20201210101238462" style="zoom: 67%;float:right;"></li>
<li><p>配置nginx.conf</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">/usr/local/nginx/cong/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改如下</span></span><br><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">  <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">  <span class="string">server_name</span> <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 注意设定 root路径是有dist的</span></span><br><span class="line">  <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">    <span class="string">root</span> <span class="string">/usr/local/webapp/dist;</span></span><br><span class="line">    <span class="string">index</span> <span class="string">/index.html;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#跨域 ip和port自行替换</span></span><br><span class="line">  <span class="string">location</span> <span class="string">/adminApi</span> &#123;</span><br><span class="line">    <span class="string">proxy_pass</span> <span class="string">http://ip:port;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动nginx</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx </span><br></pre></td></tr></table></figure>

<p><strong>常用命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置后重新启动</span></span><br><span class="line">./nginx -s reload</span><br><span class="line"><span class="meta">#</span><span class="bash">如果出现：nginx: [error] open() ＂/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid＂ failed</span></span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">再次启动即可</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看nginx进程是否启动</span></span><br><span class="line">ps -ef|grep nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">平滑启动nginx</span></span><br><span class="line">kill -HUP</span><br><span class="line"><span class="meta">#</span><span class="bash">主进程号或进程号文件路径 或者使用</span></span><br><span class="line"></span><br><span class="line">/usr/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">判断Nginx配置是否正确命令如下：</span></span><br><span class="line">nginx -t -c /usr/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">或者使用</span></span><br><span class="line">/usr/nginx/sbin/nginx -t</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">nginx reload</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload </span><br><span class="line">service nginx restart</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置nginx开机自启动</span></span><br><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">再文件中添加nginx启动地址</span></span><br><span class="line"> </span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机自启动nginx</span></span><br><span class="line">/usr/local/nginx/sb/nginx</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/23/nginx/image-20210606160947369.png" alt="image-20201210103251475"></p>
</li>
</ol>
<p>启动后访问localhost 效果如下：<br><img src="/2021/07/23/nginx/image-20201210103251475.png" alt="image-20201210103251475"></p>
<h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...... 全局块</span><br><span class="line">events &#123;</span><br><span class="line">	//events 块</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">  ....  http全局块</span><br><span class="line">	server+&#123;</span><br><span class="line">		location +[]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置内容规则"><a href="#配置内容规则" class="headerlink" title="配置内容规则"></a>配置内容规则</h3><ul>
<li>用#表示注释</li>
<li>每行配置的结尾需要加上分号</li>
<li>如果配置项值中包括语法符号，比如空格符，那么需要使用单引号或者双引号行括住配置项值，否则ngin x会报语法错误</li>
<li>单位简写：<ul>
<li>K或者k千字节（kilo byte, KB）</li>
<li>M或者m兆字节（megabyte MB）</li>
<li>ms(毫秒)，s(秒)， m(分)， h(小时) ， d (天)， w（周）， M（月，包含30天），y（年）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA内存泄漏排查</title>
    <url>/2021/08/01/outOfMemoryError/</url>
    <content><![CDATA[<h2 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="1.内存溢出"></a>1.内存溢出</h2><p>java.lang.OutOfMemoryError：是指程序在申请内存是，没有足够的内存克难攻坚供其使用，出现OutOfMemoryError</p>
<ol>
<li>产生原因<ul>
<li>JMM内存过小</li>
<li>程序不严谨，产生了过多的垃圾</li>
</ul>
</li>
<li>具体表现在以下集中情况<ul>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多的数据</li>
<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收</li>
<li>代码中存在死循环或循环过多产生过多重复的对象实体</li>
<li>使用第三方软件的bug</li>
<li>启动参数内存值设定过小</li>
</ul>
</li>
<li>常见错误提示<ul>
<li>tomcat:java.lang.OutOfMemoryError: PermGen space </li>
<li>tomcat:java.lang.OutOfMemoryError: Java heap space</li>
<li>weblogic:Root cause of ServletException java.lang.OutOfMemoryError</li>
<li>resin:java.lang.OutOfMemoryError</li>
<li>java:java.lang.OutOfMemoryError</li>
</ul>
</li>
<li>解决方法<ul>
<li>增加JVM的内存大小<br>对于tomcat容器，找到tomcat在电脑中的安装目录，进入这个目录，然后进入bin目录中，在window环境下找到bin目录中的catalina.bat，在linux环境下找到catalina.sh。<br>编辑catalina.bat文件，找到JAVA_OPTS（具体来说是 set “JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER%”）这个选项的位置，这个参数是Java启动的时候，需要的启动参数。<br>也可以在操作系统的环境变量中对JAVA_OPTS进行设置，因为tomcat在启动的时候，也会读取操作系统中的环境变量的值，进行加载。<br>如果是修改了操作系统的环境变量，需要重启机器，再重启tomcat，如果修改的是tomcat配置文件，需要将配置文件保存，然后重启tomcat，设置就能生效了</li>
<li>优化程序，释放垃圾<br>主要思路就是避免程序体现上出现的情况。避免死循环，防止一次载入太多的数据，提高程序健壮型及时释放。因此，从根本上解决Java内存溢出的唯一方法就是修改程序，及时地释放没用的对象，释放内存空间  </li>
</ul>
</li>
</ol>
<h2 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="2. 内存泄漏"></a>2. 内存泄漏</h2><p>Memory Leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。<br>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：<br>1）首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；<br>2）其次，这些对象是无用的，即程序以后不会再使用这些对象。<br>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。<br>关于内存泄露的处理页就是提高程序的健壮型，因为内存泄露是纯代码层面的问题</p>
<h2 id="3-内存溢出和内存泄漏的联系"><a href="#3-内存溢出和内存泄漏的联系" class="headerlink" title="3.内存溢出和内存泄漏的联系"></a>3.内存溢出和内存泄漏的联系</h2><p>内存泄露会最终会导致内存溢出。<br><strong>相同点</strong>：都会导致应用程序运行出现问题，性能下降或挂起。<br><strong>不同点</strong>：<br>    1) 内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。<br>    2) 内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。</p>
<h2 id="4-排查案例"><a href="#4-排查案例" class="headerlink" title="4.排查案例"></a>4.排查案例</h2><p>Java的内存泄露多半是因为对象存在无效的引用，对象得不到释放，如果发现Java应用程序占用的内存出现了泄露的迹象，那么我们一般采用下面的步骤分析：</p>
<ol>
<li>用工具生成java应用程序的heap dump（如jmap）</li>
<li>使用Java heap分析工具（如MAT），找出内存占用超出预期的嫌疑对象</li>
<li>根据情况，分析嫌疑对象和其他对象的引用关系。</li>
<li>分析程序的源代码，找出嫌疑对象数量过多的原因。</li>
</ol>
<p>实际操作如下：<br>1.登录linux服务器，获取tomcat的pid</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure>
<p>2.利用jmap初步分析内存映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -histo:live pid | head -7</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/01/outOfMemoryError/01.png" alt="jmap"><br>第2行是我们业务系统的对象，通过这个对象的引用可以初步分析出到底是哪里出现了引用未被垃圾回收收集，通知开发人员优化相关代码</p>
<p>3.如果上面一步还无法定位到关键信息，那么需要拿到heap dump，生成离线文件，做进一步分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.hprof 3514 </span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/01/outOfMemoryError/02.png" alt="jmap"><br>4. 拿到heap dump文件，利用eclipse插件MAT来分析heap profile。 </p>
<ul>
<li>1.安装MAT插件 </li>
<li>2.在eclipse里切换到Memory Analysis视图</li>
<li>3.用MAT打开heap profile文件。<br><img src="/2021/08/01/outOfMemoryError/03.png" alt="jmap"><br>直接看到下面Action窗口，有4种Action来分析heap profile，介绍其中最常用的2种:</li>
<li><strong>Histogram</strong>：这个使用的最多，跟上面的jmap -histo 命令类似，只是在MAT里面可以用GUI来展示应用系统各个类产生的实例。<br><img src="/2021/08/01/outOfMemoryError/04.png" alt="jmap"><br>Shllow Heap排序后发现 Cms_Organization 这个类占用的内存比较多（没有得到及时GC），查看引用<br><img src="/2021/08/01/outOfMemoryError/05.png" alt="jmap"><br>分析引用栈，找到无效引用，打开源码<br><img src="/2021/08/01/outOfMemoryError/06.png" alt="jmap"><br><strong>查看源码！！！</strong></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>内存溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>redis常见使用场景</title>
    <url>/2021/08/14/redis-usage-scenario/</url>
    <content><![CDATA[<h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h2><p>String类型<br>例如：热点数据缓存、对象缓存、全页缓存可以提升热点数据的访问效率</p>
<h2 id="2-数据共享分布式"><a href="#2-数据共享分布式" class="headerlink" title="2. 数据共享分布式"></a>2. 数据共享分布式</h2><p>String类型，因为redis是分布式的独立服务，可以在多个应用服务之间共享，例如分布式session</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3. 分布式锁"></a>3. 分布式锁</h2><p>String类型 setnx方法，只有不存在时才能添加成功返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Long flag = jedis.setnx(key, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        jedis.expire(key, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    jedis.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-全局ID"><a href="#4-全局ID" class="headerlink" title="4. 全局ID"></a>4. 全局ID</h2><p>int 类型， incrby, 利用原子性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">incrby userid 1000</span><br></pre></td></tr></table></figure>
<p>分库分表的场景，一次性拿一段。</p>
<h2 id="5-计数器"><a href="#5-计数器" class="headerlink" title="5. 计数器"></a>5. 计数器</h2><p>int 类型，incr方法<br>例如：文章的阅读量、微博点赞数；允许一定的延迟，先写入redis在定时同步到数据库</p>
<ol>
<li><p>第一种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(name=&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ValueOperations&lt;String,Object&gt; ops;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//此方法会先检查key是否存在，存在+1，不存在先初始化，再+1</span></span><br><span class="line">            ops.increment(<span class="string">&quot;success&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//return (int) ops.get(&quot;success&quot;); //使用这个会出现错误，报错信息 Caused by: org.springframework.core.serializer.support.SerializationFailedException: Failed to deserialize payload. Is the byte array a result of corresponding serialization for DefaultDeserializer?; nested exception is java.io.EOFException。</span></span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(redisTemplate.boundValueOps(<span class="string">&quot;success&quot;</span>).get(<span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(name=&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ValueOperations&lt;String,Object&gt; ops;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//此方法会先检查key是否存在，存在+1，不存在先初始化，再+1</span></span><br><span class="line">            ops.increment(<span class="string">&quot;success&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//return (int) ops.get(&quot;success&quot;);</span></span><br><span class="line">            <span class="comment">//return Integer.valueOf(redisTemplate.boundValueOps(&quot;success&quot;).get(0, -1));</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) getKey(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getKey</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                </span><br><span class="line">                RedisSerializer&lt;String&gt; redisSerializer = redisTemplate.getStringSerializer();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">byte</span>[] rowkey = redisSerializer.serialize(key);</span><br><span class="line">                <span class="keyword">byte</span>[] rowval = connection.get(rowkey);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String val = redisSerializer.deserialize(rowval);</span><br><span class="line">                    <span class="keyword">return</span> Long.parseLong(val);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置每天零点过期，重新计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当天时间</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//当天零点</span></span><br><span class="line">date = DateUtils.truncate(date, Calendar.DAY_OF_MONTH);</span><br><span class="line"><span class="comment">//第二天零点</span></span><br><span class="line">date = DateUtils.addDays(date, +<span class="number">1</span>);</span><br><span class="line">redisTemplate.expireAt(<span class="string">&quot;success&quot;</span>, date);</span><br></pre></td></tr></table></figure>
<h2 id="6-限流"><a href="#6-限流" class="headerlink" title="6. 限流"></a>6. 限流</h2><p>int类型，incr方法<br>以访问者的IP和其他信息作为key,访问一次增加一次次数，超过次数 则返回false</p>
</li>
</ol>
<h2 id="7-位统计"><a href="#7-位统计" class="headerlink" title="7. 位统计"></a>7. 位统计</h2><p>String类型的bitcount<br>字符是以8位二进制存储的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set k1 a</span><br><span class="line">setbit k1 6 1</span><br><span class="line">setbit k1 7 0</span><br><span class="line">get k1 </span><br><span class="line">/* 6 7 代表的a的二进制位的修改</span><br><span class="line"></span><br><span class="line">a 对应的ASCII码是97，转换为二进制数据是01100001</span><br><span class="line">b 对应的ASCII码是98，转换为二进制数据是01100010</span><br><span class="line"></span><br><span class="line">因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>例如：在线用户统计，留存用户统计</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setbit onlineusers 01 </span><br><span class="line">setbit onlineusers 11 </span><br><span class="line">setbit onlineusers 20</span><br></pre></td></tr></table></figure>
<p>支持按位与、按位或等等操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITOPANDdestkeykey[key...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。       </span><br><span class="line">BITOPORdestkeykey[key...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 </span><br><span class="line">BITOPXORdestkeykey[key...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 </span><br><span class="line">BITOPNOTdestkeykey ，对给定 key 求逻辑非，并将结果保存到 destkey 。</span><br></pre></td></tr></table></figure>
<p>计算出7天都在线的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITOP &quot;AND&quot; &quot;7_days_both_online_users&quot; &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ...  &quot;day_7_online_users&quot;</span><br></pre></td></tr></table></figure>

<h2 id="8-购物车"><a href="#8-购物车" class="headerlink" title="8. 购物车"></a>8. 购物车</h2><p>String 或hash。所有String可以做的hash都可以<br>hash类型是一个String类型的field和value的映射表，每个hash都可以存储2^32 -1键值对<br><strong>使用hash做购物车：以用户id为key, 商品id为field，商品数量为value。</strong><br><img src="/2021/08/14/redis-usage-scenario/01.png"></p>
<h2 id="9-用户消息时间线timeline"><a href="#9-用户消息时间线timeline" class="headerlink" title="9. 用户消息时间线timeline"></a>9. 用户消息时间线timeline</h2><p>list，双向链表，直接作为timeline就好了。插入有序</p>
<h2 id="10-消息队列"><a href="#10-消息队列" class="headerlink" title="10. 消息队列"></a>10. 消息队列</h2><p>List提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间</p>
<ul>
<li><p>blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
</li>
<li><p>brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。<br>上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低</p>
</li>
<li><p>队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列</p>
</li>
<li><p>栈：先进后出：rpush brpop</p>
</li>
</ul>
<h2 id="11-抽奖"><a href="#11-抽奖" class="headerlink" title="11. 抽奖"></a>11. 抽奖</h2><p>自带一个随机获得值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spop myset</span><br></pre></td></tr></table></figure>

<h2 id="12-点赞、签到、打卡"><a href="#12-点赞、签到、打卡" class="headerlink" title="12. 点赞、签到、打卡"></a>12. 点赞、签到、打卡</h2><p><img src="/2021/08/14/redis-usage-scenario/02.png" alt="点赞、签到、打卡"><br>假如上面的微博ID是t1001，用户ID是u3001</p>
<p>用 like:t1001 来维护 t1001 这条微博的所有点赞用户</p>
<ul>
<li>点赞了这条微博：sadd like:t1001 u3001</li>
<li>取消点赞：srem like:t1001 u3001</li>
<li>是否点赞：sismember like:t1001 u3001</li>
<li>点赞的所有用户：smembers like:t1001</li>
<li>点赞数：scard like:t1001</li>
</ul>
<h2 id="13-商品标签"><a href="#13-商品标签" class="headerlink" title="13. 商品标签"></a>13. 商品标签</h2><p><img src="/2021/08/14/redis-usage-scenario/03.png" alt="商品标签"><br>用 tags:i5001 来维护商品所有的标签。</p>
<ul>
<li>sadd tags:i5001 画面清晰细腻</li>
<li>sadd tags:i5001 真彩清晰显示屏</li>
<li>sadd tags:i5001 流程至极</li>
</ul>
<h2 id="14-商品筛选"><a href="#14-商品筛选" class="headerlink" title="14.商品筛选"></a>14.商品筛选</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 获取差集</span><br><span class="line">sdiff set1 set2</span><br><span class="line">// 获取交集（intersection ）</span><br><span class="line">sinter set1 set2</span><br><span class="line">// 获取并集</span><br><span class="line">sunion set1 set2</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/14/redis-usage-scenario/04.png" alt="商品筛选"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd brand:apple iPhone11</span><br><span class="line"></span><br><span class="line">sadd brand:ios iPhone11</span><br><span class="line"></span><br><span class="line">sad screensize:6.0-6.24 iPhone11</span><br><span class="line"></span><br><span class="line">sad screentype:lcd iPhone 11</span><br></pre></td></tr></table></figure>
<p>筛选商品，苹果的、ios的、屏幕在6.0-6.24之间的，屏幕材质是LCD屏幕</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter brand:apple brand:ios screensize:6.0-6.24 screentype:lcd</span><br></pre></td></tr></table></figure>
<h2 id="15-用户关注、推荐模型"><a href="#15-用户关注、推荐模型" class="headerlink" title="15. 用户关注、推荐模型"></a>15. 用户关注、推荐模型</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># follow 关注 fans 粉丝</span></span></span><br><span class="line">sadd 1:follow 2</span><br><span class="line">sadd 2:fans 1</span><br><span class="line">sadd 1:fans 2</span><br><span class="line">sadd 2:follow 1</span><br></pre></td></tr></table></figure>
<p>我关注的人也关注了他(取交集)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter 1:follow 2:fans</span><br></pre></td></tr></table></figure>
<p>可能认识的人：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 用户1可能认识的人(差集)：</span></span></span><br><span class="line">sdiff 2:follow 1:follow</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 用户2可能认识的人：</span></span></span><br><span class="line">sdiff 1:follow 2:follow</span><br></pre></td></tr></table></figure>

<h2 id="16-排行榜"><a href="#16-排行榜" class="headerlink" title="16. 排行榜"></a>16. 排行榜</h2><p>id 为6001 的新闻点击数加1：zincrby hotNews:20190926 1 n6001<br>获取今天点击最多的15条：zrevrange hotNews:20190926 0 15 withscores<br><img src="/2021/08/14/redis-usage-scenario/05.png" alt="排行榜"></p>
<hr>
<p><img src="/2021/08/14/redis-usage-scenario/06.png"></p>
<h2 id="redis不适用的场景"><a href="#redis不适用的场景" class="headerlink" title="redis不适用的场景"></a>redis不适用的场景</h2><p>Redis是一种缓存技术，主要用来提高应用的性能，更多的应用场景是对数据库读数据进行缓存，减轻数据库的IO的访问压力，以下场景不太适合使用Redis:</p>
<ul>
<li><p>数据规模大小角度</p>
<p>  Redis是将数据放在内存进行缓存的，内存相对于磁盘来锁价格是比较贵的。<strong>如果成本是需要考虑的重要因素，那么大规模的数据就不太适合</strong>；</p>
</li>
<li><p>数据冷热程度角度</p>
<p>  很多业务数据可以根据数据读的频繁程度分为热数据和冷数据；<strong>频繁使用的热数据一般适合用redis，冷数据一般不太适合用redis</strong>,如果大量的冷数据进行了缓存，那是对内存资源的浪费，<br>所以在应用场景上区分冷热数据，将热数据放在内存中，进而提高性能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下安装Redis</title>
    <url>/2021/05/13/redis_install/</url>
    <content><![CDATA[<h5 id="1-安装gcc"><a href="#1-安装gcc" class="headerlink" title="1. 安装gcc"></a>1. 安装gcc</h5>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br></pre></td></tr></table></figure>
<h5 id="2-下载安装包"><a href="#2-下载安装包" class="headerlink" title="2. 下载安装包"></a>2. 下载安装包</h5>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable.tar.gz </span><br></pre></td></tr></table></figure>
<h5 id="3-解压"><a href="#3-解压" class="headerlink" title="3. 解压"></a>3. 解压</h5>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xvzf redis-stable.tar.gz</span><br></pre></td></tr></table></figure>
<h5 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h5>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//如果使用make失败，那么就加上参数，因为jemalloc重载了Linux下的ANSI C的malloc和free函数</span><br><span class="line">make MALLOC=libc</span><br><span class="line">//make之后如果出现Hint: To run &#x27;make test&#x27; is a good idea ;</span><br><span class="line">//运行make test, 会提示需要安装tcl,执行yum install tcl</span><br></pre></td></tr></table></figure>

<h5 id="5-配置密码以及允许外网ip访问"><a href="#5-配置密码以及允许外网ip访问" class="headerlink" title="5. 配置密码以及允许外网ip访问"></a>5. 配置密码以及允许外网ip访问</h5>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在redis.conf中配置requirepass 密码以及port端口号（非必须）</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启redis允许外网ip访问，在 Linux 中安装了redis 服务，当在客户端通过远程连接的方式连接时，报could not connect错误。错误的原因为：redis采用的安全策略，默认会只准许本地访问。</span></span><br><span class="line"><span class="comment">#将所有的bing信息全部屏蔽</span></span><br><span class="line"><span class="comment">#bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#配置redis后台启动，如果不配置的话可以使用hohup启动</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>
<h5 id="6-启动redis服务"><a href="#6-启动redis服务" class="headerlink" title="6. 启动redis服务"></a>6. 启动redis服务</h5>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./src</span><br><span class="line">nohup ./redis-server ../redis.conf &amp;</span><br></pre></td></tr></table></figure>
<h5 id="7-查看redis进程"><a href="#7-查看redis进程" class="headerlink" title="7. 查看redis进程"></a>7. 查看redis进程</h5>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost redis]# pstree</span><br></pre></td></tr></table></figure>
<p>   <img src="/2021/05/13/redis_install/image-20201201155441018.png" alt="image-20201210103251475"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot读取yml配置的方式</title>
    <url>/2021/08/18/springboot-yml/</url>
    <content><![CDATA[<p>springboot项目中默认的配置文件是application.properties；</p>
<h3 id="1-yml文件规则"><a href="#1-yml文件规则" class="headerlink" title="1.yml文件规则"></a>1.yml文件规则</h3><ul>
<li>树状结构，结构清晰</li>
<li>不支持tab缩进</li>
<li>可以使用”_”或”-“消协字母代替大写字母；如userName 与user-name， user_name含义是一样的（宽松绑定原则 relaxed binding）; key: value格式书写，value前面有个空格</li>
</ul>
<h3 id="2-数据格式"><a href="#2-数据格式" class="headerlink" title="2. 数据格式"></a>2. 数据格式</h3><ul>
<li>普通的值（数字，字符串，布尔）如：  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">123</span>      </span><br><span class="line"><span class="attr">name:</span> <span class="string">abc</span>      </span><br><span class="line"><span class="attr">flag:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
  字符串默认不用加上单引号或者双引号；  “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思,name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi  ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据,name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</li>
<li>对象、Map(属性和值)如：  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#k: v：在下一行来写对象的属性和值的关系；注意缩进(不支持tab,使用空格)</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8123</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">uri-encoding:</span> <span class="string">utf-8</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/app</span></span><br></pre></td></tr></table></figure></li>
<li>数组（list， set）  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用- 值表示数组中的一个元素</span></span><br><span class="line"><span class="attr">hands:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">right</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-读取方式"><a href="#3-读取方式" class="headerlink" title="3. 读取方式"></a>3. 读取方式</h3><ol>
<li><p>@Value注解</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">public String port;</span><br></pre></td></tr></table></figure>
<p> 此处的port所在的类需要是一个组件,如果是实体类需要加上@Component</p>
</li>
<li><p>@ConfigurationProperties</p>
<p>需要一个JavaBean 来专门映射配置的话,我们一般会使用@ConfigurationProperties来读取.</p>
<p>使用的使用需要@EnableConfigurationProperties注解让类被springboot扫描到；</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3307/app?useUnicode=yes&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;useLegacyDatetimeCode=false</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prefix 指定前缀</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//省略getter setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前缀定义了哪些外部属性将绑定到类的字段上</li>
<li>根据 Spring Boot 宽松的绑定规则，类的属性名称必须与外部属性的名称匹配</li>
<li>我们可以简单地用一个值初始化一个字段来定义一个默认值</li>
<li>类本身可以是包私有的</li>
<li>类的字段必须有公共 setter 方法</li>
</ul>
</li>
<li><p>Environment</p>
<p>Spring Environment bean</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">@RestController</span></span><br><span class="line"><span class="string">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">TestC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">@Autowired</span></span><br><span class="line">    <span class="string">private</span> <span class="string">Environment</span> <span class="string">env;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">@RequestMapping(value</span> <span class="string">=</span> <span class="string">&quot;index&quot;</span>, <span class="string">method</span> <span class="string">=</span> <span class="string">RequestMethod.GET)</span></span><br><span class="line">    <span class="string">public</span> <span class="string">String</span> <span class="string">index()</span> &#123;</span><br><span class="line">        <span class="string">return</span> <span class="string">&quot;environment : &quot;</span><span class="string">+</span> <span class="string">env.getProperty(&quot;spring.datasource.druid.url&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>常见sql优化方式</title>
    <url>/2021/07/01/sql-01/</url>
    <content><![CDATA[<ol>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：    </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span>    </span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：    </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span>    </span><br><span class="line"><span class="comment">--可以这样查询：    </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span>    </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span>    </span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure></li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：    </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)    </span><br><span class="line"><span class="comment">--对于连续的数值，能用 between 就不要用 in 了：    </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>下面的查询也将导致全表扫描：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：    </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span><span class="operator">=</span><span class="number">100</span>    </span><br><span class="line"><span class="comment">---应改为:    </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">100</span><span class="operator">*</span><span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：    </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span><span class="comment">--name以abc开头的id    </span></span><br><span class="line"><span class="comment">---应改为:    </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li><p>不要写一些没有意义的查询，如需要生成一个空表结构：    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> #t <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">0</span>    </span><br><span class="line"><span class="comment">--这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：    </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> #t(...)</span><br></pre></td></tr></table></figure></li>
<li><p>很多时候用 exists 代替 in 是一个好的选择：    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="keyword">select</span> num <span class="keyword">from</span> b)    </span><br><span class="line"><span class="comment">--用下面的语句替换：    </span></span><br><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num<span class="operator">=</span>a.num)</span><br></pre></td></tr></table></figure></li>
<li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<br>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
</li>
<li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
</li>
<li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
</li>
<li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
</li>
<li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
</li>
<li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
</li>
<li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
</li>
<li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。<br>在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
</li>
<li><p>尽量避免大事务操作，提高系统并发能力。</p>
</li>
<li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java守护线程和非守护线程</title>
    <url>/2021/08/15/thread-01/</url>
    <content><![CDATA[<p>用户线程：我们平常创建的普通线程。</p>
<p>守护线程：用来服务于用户线程；不需要上层逻辑介入</p>
<p>java线程分为守护线程和非守护线程，当java jvm检测主线程或其他子线程执行完之后，守护线程也会马上停止执行，我们可以使用Thread.setDaemon(ture或false)来设置一个线程是守护线程还是非守护线程，默认为false，可以通过Thread.isDaemon()方法查询该线程是否是守护线程</p>
<p>守护线程是所有的用户线程结束生命周期，守护线程才会结束生命周期，只要有一个用户线程存在，那么守护线程就不会结束，例如Java中的垃圾 回收器就是一个守护线程，只有应用程序中所有的线程结束，它才会结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(DaemonThread::print);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程main 结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//写一个死循环的方法来测试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Counter:&quot;</span> + counter++);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程main 结束</span><br><span class="line">Counter:1</span><br></pre></td></tr></table></figure>
<p>如果我们将daemon设置为非守护线程，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>这个时候就不会退出while(true)循环了，会一直执行下去，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程main 结束</span><br><span class="line">Counter:1</span><br><span class="line">Counter:2</span><br><span class="line">Counter:3</span><br><span class="line">Counter:4</span><br><span class="line">Counter:5</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p><strong>总结：守护线程是为用户线程服务的，当用户线程全部结束，守护线程会自动结束。</strong></p>
<p><strong>注意事项：</strong></p>
<ol>
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。</li>
<li>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。</li>
<li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li>
</ol>
<p><strong>意义以及应用场景:</strong></p>
<p>当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。如：Java垃圾回收线程就是一个典型的守护线程；内存资源或者线程的管理，但是非守护线程也可以。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程的声明周期状态</title>
    <url>/2020/06/02/thread-status/</url>
    <content><![CDATA[<p><img src="/2020/06/02/thread-status/01.jpg" alt="线程的状态"></p>
<ol>
<li><p>**新建(NEW)**：新创建了一个线程对象。</p>
</li>
<li><p>**可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p>**运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p>**阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<ul>
<li><strong>等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li>
<li><strong>同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>
<li><strong>其他阻塞</strong>：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ul>
</li>
<li><p>**死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2021/08/02/volatile/</url>
    <content><![CDATA[<h2 id="1-volatile作用"><a href="#1-volatile作用" class="headerlink" title="1.volatile作用"></a>1.volatile作用</h2><p>  volatile保证有序性，可见性，不能保证原子性</p>
<ol>
<li>禁止指令重排</li>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程立即可见的</li>
<li>不能保证原子性(线程不安全)</li>
</ol>
<h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><ol>
<li>通过插入内存屏障指令禁止编译器和CPU对程序进行重排序。</li>
<li>当对声明了volatile的变量进行写操作时，JVM就会向处理器发送一条Lock前缀的指令，这条Lock前缀指令产生如下两个作用：<ul>
<li>Lock前缀指令会引起处理器缓存回写到系统内存，并使用缓存一致性机制来确保回写的原子性。</li>
<li>一个处理器的缓存回写到系统内存会导致其他处理器的缓存无效。处理器使用MESI控制协议去维护内部缓存和其他处理器缓存的一致性。处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充<h2 id="3-synchronized与volatile比较"><a href="#3-synchronized与volatile比较" class="headerlink" title="3.synchronized与volatile比较"></a>3.synchronized与volatile比较</h2></li>
</ul>
</li>
<li>volatile关键字是线程同步的轻量级实现，性能较synchronized好；但是volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块</li>
<li>synchronized关键字在java1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其他各种优化之后执行效率有了显著的提升；</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字保证数据的可见性，但是不能保证数据的原子性；synchronized关键字两者都能保证（synchronized保证原子性，有序性，可见性）</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
<li>synchronized是同步锁，同步快内的代码相当于同一时刻单线程执行</li>
</ol>
<h2 id="4-可见性问题"><a href="#4-可见性问题" class="headerlink" title="4. 可见性问题"></a>4. 可见性问题</h2><p>Java虚拟机规范中定义了一种Java内存 模型（Java Memory Model，即JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。Java内存模型的主要目标就是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的细节。</p>
<p>JMM中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work Memory），线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本。线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量。同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成<br>整体内存模型如下：<br><img src="/2021/08/02/volatile/01.png" alt="image-20201210103251475"></p>
<h3 id="4-1-synchronized"><a href="#4-1-synchronized" class="headerlink" title="4.1 synchronized"></a>4.1 synchronized</h3><p>synchronized关键字的语义JMM（Java Main Memory）有两个规定，保证其实现内存可见性：<br>    - <strong>线程解锁前，必须把共享变量的最新值刷新到主内存中</strong><br>    - <strong>线程加锁前，将清空工作内存中共享变量的值，从主内存中重新取值</strong></p>
<h3 id="4-2-volatile"><a href="#4-2-volatile" class="headerlink" title="4.2 volatile"></a>4.2 volatile</h3><ul>
<li>当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存</li>
<li>写操作会导致其他线程中的缓存无效<br>这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>在线修改静态文件</title>
    <url>/2021/05/13/%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>项目运行时，如果需要修改某个css、js、html等文件的时候，需要自己连接到服务器然后修改，更有甚者需要连接vpn、堡垒机等等，特别烦！！！！于是弄了一个在线修改静态文件的工具，在此记录一下。</p>
<h4 id="1-引入pom"><a href="#1-引入pom" class="headerlink" title="1. 引入pom"></a>1. 引入pom</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoyuge5201<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>static-file-modify-online<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-添加前后台代码"><a href="#2-添加前后台代码" class="headerlink" title="2. 添加前后台代码"></a>2. 添加前后台代码</h4><p>前台使用的是thymeleaf，根据自己项目的实际情况修改！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1oW38vpj74yKOOtbu5xGCOQ  </span><br><span class="line">密码: tcmg</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>自定义工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Centos系统以及配置IP</title>
    <url>/2021/10/01/Installing-CentOS-system/</url>
    <content><![CDATA[<h2 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h2><ol>
<li><p>安装<br> <img src="/2021/10/01/Installing-CentOS-system/1.png"></p>
</li>
<li><p>选择语言<br> <img src="/2021/10/01/Installing-CentOS-system/2.png"></p>
</li>
<li><p>设置时区以及软件安装<br> <img src="/2021/10/01/Installing-CentOS-system/3.png"></p>
</li>
<li><p>选择GNOME桌面，开发工具。然后点击左上角的完成<br><img src="/2021/10/01/Installing-CentOS-system/4.png"></p>
</li>
<li><p>配置分区，选址本地标准磁盘，并且在分区中勾选”我要配置分区”,”我想让额外空间可用”；初学者可以使用自动配置分区<br><img src="/2021/10/01/Installing-CentOS-system/5.png"></p>
</li>
<li><p>开始安装<br><img src="/2021/10/01/Installing-CentOS-system/6.png"></p>
</li>
<li><p>设置Root账户<br><img src="/2021/10/01/Installing-CentOS-system/7.png"> </p>
</li>
<li><p>等待安装成功,安装成功后会提示重启；<br><img src="/2021/10/01/Installing-CentOS-system/8.png"> </p>
</li>
</ol>
<h2 id="2-永久关闭防火墙"><a href="#2-永久关闭防火墙" class="headerlink" title="2. 永久关闭防火墙"></a>2. 永久关闭防火墙</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一、下面是red hat/CentOs7关闭防火墙的命令!</span><br><span class="line"><span class="meta">#</span><span class="bash">1:查看防火状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line">service iptables status</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">2:暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">service iptables stop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">3:永久关闭防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">4:重启防火墙</span></span><br><span class="line"></span><br><span class="line">systemctl enable firewalld</span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure>
<h2 id="3-配置SELinux"><a href="#3-配置SELinux" class="headerlink" title="3. 配置SELinux"></a>3. 配置SELinux</h2><p>SELinux是Linux 内核中提供的强制访问控制系统。selinux有disabled、permissive、enforcing 三种选择：</p>
<ul>
<li>disabled ：不启用控制系统。</li>
<li>permissive：开启控制系统，但是处于警告模式。即使你违反了策略的话它让你继续操作，但是把你的违反的内容记录下来。</li>
<li>Enforcing：开启控制系统，处于强制状态。一旦违反了策略，就无法继续操作下去</li>
</ul>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/</span><br><span class="line">vim selinux</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/01/Installing-CentOS-system/3-1.png"> </p>
<h2 id="4-修改ip配置文件"><a href="#4-修改ip配置文件" class="headerlink" title="4.修改ip配置文件"></a>4.修改ip配置文件</h2><ol>
<li><p>进入文件目录</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/   #进入配置文件</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/10/01/Installing-CentOS-system/4-1.png"> </p>
</li>
<li><p>写入配置信息并保存退出</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ifcfg-ens33 #编辑配置文件ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p> 如果要设置固定IP的话，常见设置属性有：BOOTPROTO、ONBOOT、IPADDR、NETMASK、GATEWAY</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下为配置文件的内容</span></span><br><span class="line"><span class="string">TYPE=&quot;Ethernet&quot;</span>		<span class="comment">#网卡类型（通常是Ethemet以太网）</span></span><br><span class="line"><span class="string">PROXY_METHOD=&quot;none&quot;</span>	<span class="comment">#代理方式：为关闭状态</span></span><br><span class="line"><span class="string">BROWSER_ONLY=&quot;no&quot;</span>	<span class="comment">#只是浏览器：否</span></span><br><span class="line"><span class="string">BOOTPROTO=&quot;static&quot;</span>	<span class="comment">#网卡的引导协议【static：静态IP(指定静态后IP地址就固定了,不建议采用动态分配)  dhcp：动态IP   none：不指定，不指定容易出现各种各样的网络受限】</span></span><br><span class="line"><span class="string">DEFROUTE=&quot;yes&quot;</span>		<span class="comment">#默认路由</span></span><br><span class="line"><span class="string">IPV4_FAILURE_FATAL=&quot;no&quot;</span>		<span class="comment">#是否开启IPV4致命错误检测</span></span><br><span class="line"><span class="string">IPV6INIT=&quot;yes&quot;</span>		<span class="comment">#IPV6是否自动初始化：是（现在还未用到IPV6，不会有任何影响）</span></span><br><span class="line"><span class="string">IPV6_AUTOCONF=&quot;yes&quot;</span>	<span class="comment">#IPV6是否自动配置：是（现在还未用到IPV6，不会有任何影响）</span></span><br><span class="line"><span class="string">IPV6_DEFROUTE=&quot;yes&quot;</span>	<span class="comment">#IPV6是否可以为默认路由：是（现在还未用到IPV6，不会有任何影响）</span></span><br><span class="line"><span class="string">IPV6_FAILURE_FATAL=&quot;no&quot;</span>		<span class="comment">#是否开启IPV6致命错误检测</span></span><br><span class="line"><span class="string">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span>	<span class="comment">#IPV6地址生成模型</span></span><br><span class="line"><span class="string">NAME=&quot;ens33&quot;</span>		<span class="comment">#网卡物理设备名称</span></span><br><span class="line"><span class="string">UUID=&quot;ab60d501-535b-49f5-a76b-3336a4120f64&quot;</span> <span class="comment">#通用唯一识别码，每一个网卡都会有，不能重复，否则两台linux机器只有一台可上网,可不写</span></span><br><span class="line"><span class="string">DEVICE=&quot;ens33&quot;</span>		<span class="comment">#网卡设备名称，必须和‘NAME’值一样</span></span><br><span class="line"><span class="string">ONBOOT=&quot;yes&quot;</span>		<span class="comment">#是否开机启动(如果yes则开机后自动加载使用当前配置文件)，要想网卡开机就启动或通过 `systemctl restart network`控制网卡,必须设置为 `yes`</span></span><br><span class="line"><span class="string">IPADDR=192.168.1.111</span>		<span class="comment"># 本机IP 设置固定IP 对应上面的BOOTPROTO</span></span><br><span class="line"><span class="string">NETMASK=255.255.255.0</span>		<span class="comment">#子网掩码 ,可不写</span></span><br><span class="line"><span class="string">GATEWAY=192.168.137.2</span>		<span class="comment">#默认网关 ,可不写</span></span><br><span class="line"><span class="string">DNS1=8.8.8.8</span> <span class="comment"># 可不写</span></span><br><span class="line"><span class="string">DNS2=8.8.8.5</span> <span class="comment"># 可不写</span></span><br><span class="line"><span class="string">ZONE=public</span> <span class="comment"># 可不写</span></span><br></pre></td></tr></table></figure></li>
<li><p>重启网络服务</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart  #重启网卡</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/10/01/Installing-CentOS-system/4-2.png"> </p>
</li>
<li><p>查看IP</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/10/01/Installing-CentOS-system/4-3.png"> </p>
</li>
<li><p>重启系统</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中将List列表转换为字符串</title>
    <url>/2021/10/10/list-to-string/</url>
    <content><![CDATA[<h3 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString() 方法"></a>1. toString() 方法</h3><p>List.toString()是最简单的，但它在开头和结尾添加方括号，每个字符串用逗号分隔符分隔。<br>缺点是我们不能用另一个分隔符替换逗号，也不能去掉方括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToStringUsingToStringExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// creating a list with strings.</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;One&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Two&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Three&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Five&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// converting List&lt;String&gt; to String using toString() method</span></span><br><span class="line">    String stringFromList = list.toString();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// priting the string</span></span><br><span class="line">    System.out.println(<span class="string">&quot;String : &quot;</span>+stringFromList);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：String : [One, Two, Three, Four, Five]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Java-8-String-join"><a href="#2-Java-8-String-join" class="headerlink" title="2. Java 8 String.join()"></a>2. Java 8 String.join()</h3><p>java 8 String添加了一个特殊的方法String.join()以将集合转换为具有给定分隔符的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToStringUsingString_JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// creating a list with strings.</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;One&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Two&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Three&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Five&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// converting List&lt;String&gt; to String using toString() method</span></span><br><span class="line">        String stringFromList = String.join(<span class="string">&quot;~&quot;</span>, list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// priting the string</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String with tilde delimiter: &quot;</span>+stringFromList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// delimiting with pipe | symbol.</span></span><br><span class="line">        String stringPipe = String.join(<span class="string">&quot;|&quot;</span>, list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// printing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String with pipe delimiter : &quot;</span>+stringPipe);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//  String with tilde delimiter: One~Two~Three~Four~Five</span></span><br><span class="line"><span class="comment">//  String with pipe delimiter : One|Two|Three|Four|Five</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Collectors-joining"><a href="#3-Collectors-joining" class="headerlink" title="3. Collectors.joining()"></a>3. Collectors.joining()</h3><p>Collectors.join()方法来自 java 8 stream api。Collctors.joining()方法将分隔符、前缀和后缀作为参数。此方法将列表转换为具有给定分隔符、前缀和后缀的字符串。</p>
<p>查看以下有关使用不同分隔符的 join() 方法的示例。但是，String.join() 方法不提供前缀和后缀选项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToStringUsingString_JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// creating a list with strings.</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;One&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Two&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Three&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Five&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// using java 8 Collectors.joining with delimiter, prefix and suffix</span></span><br><span class="line">        String joiningString = list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line">        <span class="comment">// printing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Collectors.joining string : &quot;</span>+joiningString);</span><br><span class="line">        String joiningString3 = list.stream().collect(Collectors.joining(<span class="string">&quot;@&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="comment">// printing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Collectors.joining string with @ separator : &quot;</span>+joiningString3);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Collectors.joining string : &#123;One-Two-Three-Four-Five&#125;</span></span><br><span class="line"><span class="comment">//Collectors.joining string with @ separator : One@Two@Three@Four@Five</span></span><br></pre></td></tr></table></figure>
<h3 id="4-Apache-Commons-StringUtils-join"><a href="#4-Apache-Commons-StringUtils-join" class="headerlink" title="4. Apache Commons StringUtils.join()"></a>4. Apache Commons StringUtils.join()</h3><p>使用来自 apache commons 包的外部库。该库有一个方法StringUtils.join() ，它采用类似于 String.join() 方法的列表和分隔符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToStringUsingStringUtils_JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// creating a list with strings.</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;One&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Two&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Three&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;Five&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// using java 8 Collectors.joining with delimiter, prefix and suffix</span></span><br><span class="line">        String joiningString = StringUtils.join(list, <span class="string">&quot;^&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// printing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringUtils.join string with ^ delimiter : &quot;</span>+joiningString);</span><br><span class="line">        </span><br><span class="line">        String joiningString3 = StringUtils.join(list, <span class="string">&quot;$&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// printing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;StringUtils.join string with @ separator : &quot;</span>+joiningString3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//  StringUtils.join string with ^ delimiter : One^Two^Three^Four^Five</span></span><br><span class="line"><span class="comment">//  StringUtils.join string with @ separator : One$Two$Three$Four$Five</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>list</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux关机命令</title>
    <url>/2021/10/02/shutdown/</url>
    <content><![CDATA[<h3 id="1-shutdown命令"><a href="#1-shutdown命令" class="headerlink" title="1. shutdown命令"></a>1. shutdown命令</h3><p>shutdown会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。<br>你可以指定一个时间字符串（通常是 now或者用hh:mm 指定小时/分钟）作为第一个参数。</p>
<p>shutdown命令示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown</span><br><span class="line"></span><br><span class="line">shutdown now  #立即关机</span><br><span class="line"></span><br><span class="line">shutdown 13:20  # 下午13：20关机</span><br><span class="line"></span><br><span class="line">shutdown -p now  ### 关闭机器</span><br><span class="line"></span><br><span class="line">shutdown -H now  ### 停止机器      </span><br><span class="line"></span><br><span class="line">shutdown -r09:35 ### 在 09:35am 重启机器</span><br><span class="line"></span><br><span class="line">shutdown -c  ## 取消关机</span><br></pre></td></tr></table></figure>

<h3 id="2-halt-命令"><a href="#2-halt-命令" class="headerlink" title="2. halt 命令"></a>2. halt 命令</h3><p>halt通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。<br>注意在有些情况会它会完全关闭系统。</p>
<p>halt 命令示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">halt             ### 停止机器</span><br><span class="line"></span><br><span class="line">halt -p          ### 关闭机器</span><br><span class="line"></span><br><span class="line">halt --reboot    ### 重启机器</span><br></pre></td></tr></table></figure>

<h3 id="3-poweroff-命令"><a href="#3-poweroff-命令" class="headerlink" title="3.poweroff 命令"></a>3.poweroff 命令</h3><p>poweroff会发送一个 ACPI 信号来通知系统关机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">poweroff           ### 关闭机器</span><br><span class="line"></span><br><span class="line">poweroff --halt    ### 停止机器</span><br><span class="line"></span><br><span class="line">poweroff --reboot  ### 重启机器</span><br></pre></td></tr></table></figure>

<h3 id="4-reboot-命令"><a href="#4-reboot-命令" class="headerlink" title="4.reboot 命令"></a>4.reboot 命令</h3><p>reboot 通知系统重启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot           ### 重启机器</span><br><span class="line"></span><br><span class="line">reboot --halt    ### 停止机器</span><br><span class="line"></span><br><span class="line">reboot -p        ### 关闭机器</span><br></pre></td></tr></table></figure>

<p>###5. init 命令<br>一. init是Linux系统操作中不可缺少的程序之一。<br>所谓的init进程，它是一个由内核启动的用户级进程。<br>内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。<br>内核会在过去曾使用过init的几个地方查找它，它的正确位置（对Linux系统来说）是/sbin/init。如果内核找不到init，它就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。</p>
<p>二. init一共分为7个级别，这7个级别的所代表的含义如下</p>
<p>0：停机或者关机（千万不能将initdefault设置为0）</p>
<p>1：单用户模式，只root用户进行维护</p>
<p>2：多用户模式，不能使用NFS(Net File System)</p>
<p>3：完全多用户模式（标准的运行级别）</p>
<p>4：安全模式</p>
<p>5：图形化（即图形界面）</p>
<p>6：重启（千万不要把initdefault设置为6）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shutdown</tag>
      </tags>
  </entry>
  <entry>
    <title>转换成小写字母</title>
    <url>/2021/08/22/algoright-2/</url>
    <content><![CDATA[<p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure>
<h3 id="方法一：-ASCCII码"><a href="#方法一：-ASCCII码" class="headerlink" title="方法一： ASCCII码"></a>方法一： ASCCII码</h3><p><strong>解题思路：通过ascii码表操作字符串即可,a和A相差32；</strong></p>
<ul>
<li>a-z: 97 - 122</li>
<li>A-Z: 65 - 90</li>
<li>0-9: 48 - 57<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// a-z：97-122  A-Z：65-90  0-9：48-57</span></span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(ch + <span class="number">32</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            ch[i] += <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法二：-位运算"><a href="#方法二：-位运算" class="headerlink" title="方法二： 位运算"></a>方法二： 位运算</h3><p><strong>解题思路：</strong></p>
<ul>
<li>大写变小写、小写变大写：字符 ^= 32;</li>
<li>大写变小写、小写变小写：字符 |= 32;</li>
<li>大写变大写、小写变大写：字符 &amp;= 33;</li>
</ul>
<p>ASCII码表中大写的A是65，小写的a是97，它们的差是32<br>65 | 32 转为二进制（按8位来算）可以得到 0100 0001 | 0010 0000 = 0110 0001 = 97 = a</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        ch[i] |= <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldumpslow分析慢查询日志</title>
    <url>/2021/08/21/mysqldumpslow%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>按照平均查询输出5行慢查询记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s at -t 5 /phpstudy/data/slowquery.log</span><br></pre></td></tr></table></figure>
<ul>
<li>-s   排序方式，可选值有c（记录次数）、t（查询时间）、l（锁定时间）、r（返回记录）、a（平均）</li>
<li>-t    显示的记录数Spawn failed解决方式</li>
<li>-g   后面跟正则表达式（如 left join），不区分大小写。</li>
<li>-r   正序排序，即从小到大排序。</li>
<li>-d  调试 debug</li>
<li>-v   查看版本</li>
</ul>
<p>按照平均查询时间排序且只显示含有left join的记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s at -g &#x27;left join&#x27; /phpstudy/data/slowquery.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql行列转置</title>
    <url>/2021/08/25/mysql%E8%A1%8C%E5%88%97%E8%BD%AC%E7%BD%AE/</url>
    <content><![CDATA[<p>数据表：<br><img src="/2021/08/25/mysql%E8%A1%8C%E5%88%97%E8%BD%AC%E7%BD%AE/01.png" alt="原始数据"></p>
<p>行转列结果为：<br><img src="/2021/08/25/mysql%E8%A1%8C%E5%88%97%E8%BD%AC%E7%BD%AE/02.png" alt="转置后结果"><br>数据库表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_score(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,  #名字</span><br><span class="line">    Subject <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>, #科目</span><br><span class="line">    Fraction <span class="keyword">double</span> <span class="keyword">default</span> <span class="number">0</span>  #分数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_score`(name,Subject,Fraction) <span class="keyword">VALUES</span></span><br><span class="line">     (<span class="string">&#x27;王海&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="number">86</span>),</span><br><span class="line">     (<span class="string">&#x27;王海&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="number">83</span>),</span><br><span class="line">     (<span class="string">&#x27;王海&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">93</span>),</span><br><span class="line">     (<span class="string">&#x27;陶俊&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="number">88</span>),</span><br><span class="line">     (<span class="string">&#x27;陶俊&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="number">84</span>),</span><br><span class="line">     (<span class="string">&#x27;陶俊&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">94</span>),</span><br><span class="line">     (<span class="string">&#x27;刘可&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="number">80</span>),</span><br><span class="line">     (<span class="string">&#x27;刘可&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="number">86</span>),</span><br><span class="line">     (<span class="string">&#x27;刘可&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>),</span><br><span class="line">     (<span class="string">&#x27;李春&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="number">89</span>),</span><br><span class="line">     (<span class="string">&#x27;李春&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="number">80</span>),</span><br><span class="line">     (<span class="string">&#x27;李春&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">87</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>方法一：使用if <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    name <span class="keyword">as</span> 名字 ,</span><br><span class="line">    <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;语文&#x27;</span>,Fraction,<span class="number">0</span>)) <span class="keyword">as</span> 语文,</span><br><span class="line">    <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;数学&#x27;</span>,Fraction,<span class="number">0</span>))<span class="keyword">as</span> 数学, </span><br><span class="line">    <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span>,Fraction,<span class="number">0</span>))<span class="keyword">as</span> 英语,</span><br><span class="line">    round(<span class="built_in">AVG</span>(Fraction),<span class="number">2</span>) <span class="keyword">as</span> 平均分,</span><br><span class="line">    <span class="built_in">SUM</span>(Fraction) <span class="keyword">as</span> 总分</span><br><span class="line"><span class="keyword">from</span> t_score <span class="keyword">group</span> <span class="keyword">by</span> name</span><br><span class="line"><span class="comment">-- 如果不用求总分的话，不需要下面的union</span></span><br><span class="line"><span class="keyword">union</span>(</span><br><span class="line">    <span class="keyword">select</span> name <span class="keyword">as</span> 名字 , <span class="built_in">sum</span>(语文) Chinese,<span class="built_in">sum</span>(数学) Math,<span class="built_in">sum</span>(英语) English,round(<span class="built_in">AVG</span>(总分),<span class="number">2</span>)<span class="keyword">as</span> 平均分,<span class="built_in">sum</span>(总分) score  <span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="string">&#x27;TOTAL&#x27;</span> <span class="keyword">as</span> name,</span><br><span class="line">        <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;语文&#x27;</span>,Fraction,<span class="number">0</span>)) <span class="keyword">as</span> 语文,</span><br><span class="line">        <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;数学&#x27;</span>,Fraction,<span class="number">0</span>))<span class="keyword">as</span> 数学, </span><br><span class="line">        <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span>,Fraction,<span class="number">0</span>))<span class="keyword">as</span> 英语,</span><br><span class="line">        <span class="built_in">SUM</span>(Fraction) <span class="keyword">as</span> 总分</span><br><span class="line">        <span class="keyword">from</span> t_score <span class="keyword">group</span> <span class="keyword">by</span> Subject </span><br><span class="line">    )t <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.`name`</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>方法二：使用case <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> name,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> Subject <span class="operator">=</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">then</span> Fraction <span class="keyword">end</span>) <span class="keyword">as</span> Chinese,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> Subject <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">then</span> Fraction <span class="keyword">end</span>) <span class="keyword">as</span> Math,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> Subject <span class="operator">=</span> <span class="string">&#x27;英语&#x27;</span> <span class="keyword">then</span> Fraction <span class="keyword">end</span>) <span class="keyword">as</span> English,</span><br><span class="line"><span class="built_in">sum</span>(fraction)<span class="keyword">as</span> score</span><br><span class="line"><span class="keyword">from</span> t_score <span class="keyword">group</span> <span class="keyword">by</span> name</span><br><span class="line"><span class="comment">-- 如果不用求总分的话，不需要下面的union</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> name <span class="keyword">as</span> Name,<span class="built_in">sum</span>(Chinese) <span class="keyword">as</span> Chinese,<span class="built_in">sum</span>(Math) <span class="keyword">as</span> Math,<span class="built_in">sum</span>(English) <span class="keyword">as</span> English,<span class="built_in">sum</span>(score) <span class="keyword">as</span> score <span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="string">&#x27;TOTAL&#x27;</span> <span class="keyword">as</span> name,</span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> Subject <span class="operator">=</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">then</span> Fraction <span class="keyword">end</span>) <span class="keyword">as</span> Chinese,</span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> Subject <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">then</span> Fraction <span class="keyword">end</span>) <span class="keyword">as</span> Math,</span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> Subject <span class="operator">=</span> <span class="string">&#x27;英语&#x27;</span> <span class="keyword">then</span> Fraction <span class="keyword">end</span>) <span class="keyword">as</span> English,</span><br><span class="line">    <span class="built_in">sum</span>(fraction)<span class="keyword">as</span> score</span><br><span class="line">    <span class="keyword">from</span> t_score <span class="keyword">group</span> <span class="keyword">by</span> Subject,name)t <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.`name`</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>方法三：使用with rollup<br>在group分组字段的基础上在进行统计数据； <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="comment">-- coalesce(name,&#x27;TOTAL&#x27;) name,</span></span><br><span class="line">    ifnull(name,<span class="string">&#x27;TOTAL&#x27;</span>) name,</span><br><span class="line">    <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;语文&#x27;</span>,Fraction,<span class="number">0</span>)) <span class="keyword">as</span> 语文,</span><br><span class="line">    <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;英语&#x27;</span>,Fraction,<span class="number">0</span>)) <span class="keyword">as</span> 英语,</span><br><span class="line">    <span class="built_in">sum</span>(if(Subject<span class="operator">=</span><span class="string">&#x27;数学&#x27;</span>,Fraction,<span class="number">0</span>))<span class="keyword">as</span> 数学,</span><br><span class="line">    <span class="built_in">sum</span>(Fraction) 总分</span><br><span class="line"><span class="keyword">from</span> t_score <span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">with</span> <span class="keyword">rollup</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>LockSupport 一个很灵活的线程工具类</title>
    <url>/2021/09/25/locksupport/</url>
    <content><![CDATA[<p>LockSupport是一个编程工具类， 主要是为了阻塞和唤醒线程用的。所有的方法都是静态方法，可以让线程在任意位置阻塞，也可以在任意位置唤醒</p>
<p>主要的方法： park(阻塞线程)  和  unpark(启动唤醒线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockSupport</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Cannot be instantiated.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Even though volatile, hotspot doesn&#x27;t need a write barrier here.</span></span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread the thread to unpark, or &#123;<span class="doctag">@code</span> null&#125;, in which case</span></span><br><span class="line"><span class="comment">     *        this operation has no effect</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞当前线程</span></span><br><span class="line"><span class="comment">     * blocker是用来记录线程被阻塞时被谁阻塞的。用于线程监控和分析工具来定位原因的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker the synchronization object responsible for this</span></span><br><span class="line"><span class="comment">     *        thread parking</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//setBlocker作用是记录t线程是被broker阻塞的</span></span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        <span class="comment">//UNSAFE是一个非常强大的类，他的的操作是基于底层的</span></span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停当前线程，有超时时间</span></span><br><span class="line"><span class="comment">     * blocker是用来记录线程被阻塞时被谁阻塞的。用于线程监控和分析工具来定位原因的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker the synchronization object responsible for this</span></span><br><span class="line"><span class="comment">     *        thread parking</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos the maximum number of nanoseconds to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            setBlocker(t, blocker);</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">            setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停当前线程，知道某个时间</span></span><br><span class="line"><span class="comment">     * blocker是用来记录线程被阻塞时被谁阻塞的。用于线程监控和分析工具来定位原因的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker the synchronization object responsible for this</span></span><br><span class="line"><span class="comment">     *        thread parking</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deadline the absolute time, in milliseconds from the Epoch,</span></span><br><span class="line"><span class="comment">     *        to wait until</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the blocker object supplied to the most recent</span></span><br><span class="line"><span class="comment">     * invocation of a park method that has not yet unblocked, or null</span></span><br><span class="line"><span class="comment">     * if not blocked.  The value returned is just a momentary</span></span><br><span class="line"><span class="comment">     * snapshot -- the thread may have since unblocked or blocked on a</span></span><br><span class="line"><span class="comment">     * different blocker object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the blocker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if argument is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无期限暂停当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停当前线程，不过有超时时间限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>)</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停当前线程，知道某个时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deadline 暂停结束时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the pseudo-randomly initialized or updated secondary seed.</span></span><br><span class="line"><span class="comment">     * Copied from ThreadLocalRandom due to package access restrictions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextSecondarySeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> ((r = UNSAFE.getInt(t, SECONDARY)) != <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">            r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((r = java.util.concurrent.ThreadLocalRandom.current().nextInt()) == <span class="number">0</span>)</span><br><span class="line">            r = <span class="number">1</span>; <span class="comment">// avoid zero</span></span><br><span class="line">        UNSAFE.putInt(t, SECONDARY, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;parkBlocker&quot;</span>));</span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSeed&quot;</span>));</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomProbe&quot;</span>));</span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSecondarySeed&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="与wait-notify对比"><a href="#与wait-notify对比" class="headerlink" title="与wait / notify对比"></a>与wait / notify对比</h3><p>LockSupport是用来阻塞和环线线程的，wait/notify同样也是，那么两者的区别是什么？</p>
<ul>
<li>wait和notify都是Object中的方法，在调用这两个方法前必须获得锁对象，但是park不需要获取某个对象的锁就可以锁住线程</li>
<li>notify只能随机选择一个线程唤醒，无法唤醒指定的线程，unpark可以唤醒一个指定的线程</li>
</ul>
<h3 id="LockSupport使用"><a href="#LockSupport使用" class="headerlink" title="LockSupport使用"></a>LockSupport使用</h3><h4 id="1-先interrupt在park"><a href="#1-先interrupt在park" class="headerlink" title="1. 先interrupt在park"></a>1. 先interrupt在park</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span>  <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;是否中断：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程启动了，但是在内部进行了park&quot;</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//       线程启动了，但是在内部进行了park</span></span><br><span class="line"><span class="comment">//       main 线程结束</span></span><br><span class="line"><span class="comment">//       Thread-0进入线程</span></span><br><span class="line"><span class="comment">//       运行结束</span></span><br></pre></td></tr></table></figure>
<h4 id="2-先park在interrupt"><a href="#2-先park在interrupt" class="headerlink" title="2. 先park在interrupt"></a>2. 先park在interrupt</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span>  <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * 线程启动了，但是在内部进行了park</span></span><br><span class="line"><span class="comment"> * main 线程结束</span></span><br><span class="line"><span class="comment"> * Thread-0进入线程</span></span><br><span class="line"><span class="comment"> * 运行结束</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="趣味题"><a href="#趣味题" class="headerlink" title="趣味题"></a>趣味题</h3><p>用两个线程，一个输出字母，一个输出数字交替输出如：1A2B3C4D…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">null</span>, t2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] a = <span class="string">&quot;1234567&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] b = <span class="string">&quot;ABCDEFG&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> i : a) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                LockSupport.unpark(t2);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> i : b) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                LockSupport.unpark(t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：  1A2B3C4D5E6F7G</span></span><br></pre></td></tr></table></figure>
<p>使用自旋锁也可以实现上面的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义枚举，包含两个变量</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ReadyToRun</span></span>&#123;T1, T2&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> ReadyToRun r = ReadyToRun.T1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] a = <span class="string">&quot;1234567&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] b = <span class="string">&quot;ABCDEFG&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : a)&#123;</span><br><span class="line">                <span class="comment">//当r不为T1时， 空转占着cpu等待，然后输出字符，将r的值设置为T2</span></span><br><span class="line">                <span class="keyword">while</span> (r != ReadyToRun.T1)&#123;&#125;</span><br><span class="line">                System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                r = ReadyToRun.T2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : b)&#123;</span><br><span class="line">                <span class="keyword">while</span> (r != ReadyToRun.T2)&#123;&#125;</span><br><span class="line">                System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                r = ReadyToRun.T1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat学习</title>
    <url>/2021/07/23/mycat/</url>
    <content><![CDATA[<h1 id="Mycat-分库分表中间件"><a href="#Mycat-分库分表中间件" class="headerlink" title="Mycat(分库分表中间件)"></a>Mycat(分库分表中间件)</h1><h2 id="1-数据库优化策略"><a href="#1-数据库优化策略" class="headerlink" title="1. 数据库优化策略"></a>1. 数据库优化策略</h2><ol>
<li> 重启：释放资源</li>
<li> SQL与索引</li>
<li> 表与存储引擎（字段类型选择，长度设置，是否需要分表、分区）</li>
<li> 数据库与应用架构（考虑使用缓存服务器，减轻是数据库压力；可以数据库分布式，读写分离，主从复制）</li>
<li> 数据库与操作系统配置（修改mysql配置，使用单独服务器部署数据库）</li>
<li> 硬件</li>
</ol>
<h2 id="2-数据库演化"><a href="#2-数据库演化" class="headerlink" title="2. 数据库演化"></a>2. 数据库演化</h2><p>根据业务需要、数据量变化，随之而来的数据库的变化</p>
<ol>
<li><p> 数据库与应用部署在同一台服务器<br><img src="/2021/07/23/mycat/image-20201104204430049.png" alt="mycat"></p>
</li>
<li><p>单体应用架构，单数据库（数据库服务器和应用服务器分离，但是业务系统越做越大）<br> <img src="/2021/07/23/mycat/image-20201104204624925.png" alt="mycat"></p>
</li>
<li><p>多应用单数据库（应用解耦）<br> <img src="/2021/07/23/mycat/image-20201104204933409.png" alt="mycat"></p>
</li>
<li><p>多应用 独立数据库<br> <img src="/2021/07/23/mycat/image-20201104205054233.png" alt="mycat"></p>
</li>
<li><p>但应用多数据库(分表)<br> <img src="/2021/07/23/mycat/image-20201104205319372.png" alt="mycat"></p>
</li>
</ol>
<h2 id="3-如何分库分表"><a href="#3-如何分库分表" class="headerlink" title="3. 如何分库分表"></a>3. 如何分库分表</h2><p><img src="/2021/07/23/mycat/image-20201104205653611.png" alt="mycat"></p>
<ul>
<li><p>垂直切分</p>
<ul>
<li><p>单库<br>  <img src="/2021/07/23/mycat/image-20201104205756827.png" alt="mycat"></p>
</li>
<li><p>多库<br>  <img src="/2021/07/23/mycat/image-20201104210008624.png" alt="mycat"></p>
</li>
</ul>
</li>
<li><p>水平切分</p>
<ul>
<li><p>按照月分表或者分成实时、历史表等<br>  <img src="/2021/07/23/mycat/image-20201104210117373.png" alt="mycat"></p>
</li>
<li><p>分成多库<br>  <img src="/2021/07/23/mycat/image-20201104210416994.png" alt="mycat"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-分库分表带来的问题"><a href="#4-分库分表带来的问题" class="headerlink" title="4. 分库分表带来的问题"></a>4. 分库分表带来的问题</h2><ol>
<li><p>跨库关联查询</p>
<ul>
<li>  增加冗余字段（违反了第三范式：表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系）</li>
<li>  跨数据库的同步（canal、Mq（最好）、ETL、kettle、ogg）(在某个库中同步其他数据库中表的数据，避免跨库关联查询)</li>
<li>  全局表(广播表)：比如行政区划表，所有的系统都是一样的；</li>
<li>  API</li>
</ul>
</li>
<li><p>分布式事务</p>
<ul>
<li>  Local</li>
</ul>
</li>
<li><p>排序、翻页、函数计算</p>
<p> -</p>
</li>
<li><p>全局主键</p>
<ul>
<li>  雪花算法leaf</li>
<li>  redis(int 类型可以设置incby)</li>
<li>  ZookKeeper</li>
<li>  uuid(数据过长， 影响索引存储)</li>
</ul>
</li>
<li><p>多数据源连接（动态数据源）<br> <img src="/2021/07/23/mycat/image-20201104213343204.png" alt="mycat"></p>
</li>
</ol>
<h2 id="5-Mycat分库分表中间件"><a href="#5-Mycat分库分表中间件" class="headerlink" title="5. Mycat分库分表中间件"></a>5. Mycat分库分表中间件</h2><p><strong>官网地址</strong>：<a href="http://www.mycat.org.cn/">http://www.mycat.org.cn/</a></p>
<p>从阿里cobar升级而来，完全实现了mysql协议，可以当作一个mysql数据库来使用，通过JDBC支持其他数据库实现分库分表，解决了<strong>多表join、分布式事务、全局序列号、翻页查询、函数计算</strong>的问题</p>
<ul>
<li>  一个彻底开源的，面向企业应用开发的大数据库集群</li>
<li>  支持事务、ACID、可以替代MySQL的加强版数据库</li>
<li>  一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群</li>
<li>  一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server</li>
<li>  结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</li>
<li>  一个新颖的数据库中间件产品</li>
</ul>
<p>华为云的DDM其实也是根据mycat做的</p>
<h3 id="5-1-核心概念"><a href="#5-1-核心概念" class="headerlink" title="5.1 核心概念"></a>5.1 核心概念</h3><p><img src="/2021/07/23/mycat/image-20201104215015366.png" alt="image-20201104215015366"></p>
<h3 id="5-2-Mycat安装与配置"><a href="#5-2-Mycat安装与配置" class="headerlink" title="5.2 Mycat安装与配置"></a>5.2 Mycat安装与配置</h3><h4 id="5-2-1-Mycat安装"><a href="#5-2-1-Mycat安装" class="headerlink" title="5.2.1 Mycat安装"></a>5.2.1 Mycat安装</h4><p>从官网下载安装版本，解压到文件(官网建议安装在/usr/local/Mycat)后页面如下图所示：<br><img src="/2021/07/23/mycat/image-20201127094703483.png" alt="image-20201127094703483"></p>
<p>目录解释如下：</p>
<ul>
<li><strong>bin：</strong>存放window版和linux版本除了提供封装成服务的版本之外，也提供了nowrap的shell脚本命令，方便选择和修改；Linux下运行:./mycat console， 首先要chmod + x*;(mycat支持的命令console、start、stop、restart、status、dump)</li>
<li><strong>conf：</strong>server.xml是mycat服务器参数调整和用户授权的配置文件，schema.xml是逻辑库定义和表以及分片定义的配置文件，rule.xml是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改，需要重启mycat或者通过9066端口reload</li>
<li>**lib:**主要存放mycat依赖的一些jar文件</li>
<li><strong>logs:<strong>日志存放在mycat.log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要，可以调整输出级别为debug，方便排查问题；注意Linux下部署安装mysql，默认不忽略，需要手动到/etc/my.cnf下配置</strong>lower_case_table_names=1</strong>使Linux环境下MySQL忽略表明大小写，否则使用mycat的时候会提示找不到表的错误</li>
</ul>
<h4 id="5-2-2-服务启动与配置"><a href="#5-2-2-服务启动与配置" class="headerlink" title="5.2.2 服务启动与配置"></a>5.2.2 服务启动与配置</h4><p>Mycat在Linux中部署启动时，首先需要在Linux系统的环境变量中配置MYCAT_HOE,操作方式如下：</p>
<ol>
<li><p>vi /etc/profile，在系统环境变量文件中增加MYCAT_HOME=/usr/lib/tools/mycat<br><img src="/2021/07/23/mycat/image-20201127103212598.png" alt="image-20201127103212598"></p>
</li>
<li><p>执行 source/etc/profile命令，使环境变量生效。如果是多台Linux系统中组件Mycat集群，那需要在mycat Server所在的服务器配置对其他ip和主机名的映射，配置方式如下：<br><img src="/2021/07/23/mycat/image-20201127104159580.png" alt="image-20201127104159580"></p>
<p>经过以上两个步骤的配置，就可以到/usr/lib/tools/mycat/bin目录下执行./mycat start启动mycat服务；使用mycat status查看mycat的运行状态；如下图<br><img src="/2021/07/23/mycat/image-20201128135953635.png" alt="image-20201128135953635"></p>
</li>
</ol>
<h5 id="5-2-2-1-安装遇到的问题"><a href="#5-2-2-1-安装遇到的问题" class="headerlink" title="5.2.2.1 安装遇到的问题"></a>5.2.2.1 安装遇到的问题</h5><ol>
<li><p>schema TESTDB refered by user root is not exist!<img src="/2021/07/23/mycat/image-20201215152125176.png" alt="image-20201215152125176"></p>
<p>解决方式：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在conf/server.xml文件中schemas中配置schema.xml文件中的schema的name值--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--user中的name为mycat服务的用户名--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--这个是mycat服务连接的密码--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>xiaoyuge<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-2-3日志分析"><a href="#5-2-3日志分析" class="headerlink" title="5.2.3日志分析"></a>5.2.3日志分析</h4><p>mycat的日志文件配置为MYCAT_HOME/conf/log4j.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ConsoleAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;MM-dd HH:mm:ss.SSS&#125; %5p [%t] (%F:%L) -%m%n&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件存放的目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;MYCAT_HOME&#125;/logs/mycat.log&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Append&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;MaxFileSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000KB&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;MaxBackupIndex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;MM/dd HH:mm:ss.SSS&#125; %5p [%t] (%F:%L) -%m%n&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--level是日志级别，生产环境下加以将级别调整为info/ware，如果是研究测试，碰到异常设置为debug--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ConsoleAppender&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-1-warpper日志"><a href="#5-2-3-1-warpper日志" class="headerlink" title="5.2.3.1 warpper日志"></a>5.2.3.1 warpper日志</h5><p>目前mycat的启动时经过warpper封装成启动脚本，所以日志也会有其相关的日志文件：${MYCAT_HOME}/logs/warapper.log， 在启动的时候如果系统环境配置错误或缺少配置时，导致mycat无法启动，可以通过查看wrapper.log查看具体错误原因。</p>
<ol>
<li><p>正常启动</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">STATUS | wrapper | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">00</span> | --&gt; Wrapper Started as Daemon</span><br><span class="line">STATUS | wrapper | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">00</span> | Launching a JVM...</span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">01</span> | Wrapper (Version <span class="number">3</span><span class="variable">.2</span><span class="variable">.3</span>) http:<span class="comment">//wrapper.tanukisoftware.org</span></span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">01</span> | Copyright <span class="number">1999</span>-<span class="number">2006</span> Tanuki Software, Inc. AllRights Reserved.</span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">01</span> |</span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">01</span> | log4j <span class="number">2015</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">01</span> [./conf/log4j<span class="variable">.xml</span>]load completed.</span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">04</span>/<span class="number">12</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">02</span> | MyCAT Server startup successfully. see logs in logs/mycat<span class="variable">.log</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动异常</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">STATUS | wrapper | <span class="number">2015</span>/<span class="number">02</span>/<span class="number">14</span> <span class="number">01</span>:<span class="number">43</span>:<span class="number">44</span> | --&gt; Wrapper Started as Daemon</span><br><span class="line">STATUS | wrapper | <span class="number">2015</span>/<span class="number">02</span>/<span class="number">14</span> <span class="number">01</span>:<span class="number">43</span>:<span class="number">44</span> | Launching a JVM...</span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">02</span>/<span class="number">14</span> <span class="number">01</span>:<span class="number">43</span>:<span class="number">45</span> | Error: Exception thrown by the agent : java<span class="variable">.rmi</span><span class="variable">.server</span><span class="variable">.ExportException</span>:</span><br><span class="line">Port already in <span class="keyword">use</span>: <span class="number">1984</span>; nested exception is:</span><br><span class="line">INFO | jvm <span class="number">1</span> | <span class="number">2015</span>/<span class="number">02</span>/<span class="number">14</span> <span class="number">01</span>:<span class="number">43</span>:<span class="number">45</span> | java<span class="variable">.net</span><span class="variable">.BindException</span>: Address already in <span class="keyword">use</span></span><br><span class="line">ERROR | wrapper | <span class="number">2015</span>/<span class="number">02</span>/<span class="number">14</span> <span class="number">01</span>:<span class="number">43</span>:<span class="number">45</span> | JVM exited <span class="keyword">while</span> loading the application.</span><br><span class="line">    </span><br><span class="line"># 日志显示异常原因为 java<span class="variable">.net</span><span class="variable">.BindException</span>: Address already in <span class="keyword">use</span>,也就是端口占用，很有可能是原有服</span><br><span class="line">务未停止，或者 Mycat 默认端口被其他程序占用，正常启动成功后会有 mycat<span class="variable">.log</span> 日志，如果服务未启动成功不会有对应的日志。 也可以去修改 conf 文件夹里的 wrapper<span class="variable">.conf</span> 里的 wrapper<span class="variable">.java</span><span class="variable">.additional</span><span class="variable">.7</span>=-Dcom<span class="variable">.sun</span><span class="variable">.management</span><span class="variable">.jmxremote</span><span class="variable">.port</span>=<span class="number">1984</span>，server<span class="variable">.xml</span> 的&lt;<span class="keyword">property</span> name=<span class="string">&quot;serverPort&quot;</span>&gt;<span class="number">8066</span>&lt;/<span class="keyword">property</span>&gt;和</span><br><span class="line">&lt;<span class="keyword">property</span> name=<span class="string">&quot;managerPort&quot;</span>&gt;<span class="number">9066</span>&lt;/<span class="keyword">property</span>&gt;，这方法适</span><br><span class="line">合一台机器上两个 mycat 或者 <span class="number">1984</span>,<span class="number">8066</span>,<span class="number">9066</span> 端口被其它应用占用的情况</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="5-2-3-2-mycat日志"><a href="#5-2-3-2-mycat日志" class="headerlink" title="5.2.3.2 mycat日志"></a>5.2.3.2 mycat日志</h5><h4 id="5-2-4-mycat防火墙设置"><a href="#5-2-4-mycat防火墙设置" class="headerlink" title="5.2.4 mycat防火墙设置"></a>5.2.4 mycat防火墙设置</h4><p>白名单和SQL黑名单说明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在 server.xml 中配置：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--ip 白名单列表，可以配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ip 白名单 用户对应的可以访问的 ip 地址--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">host</span> <span class="attr">user</span>=<span class="string">&quot;mycat&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line">     &lt;!-是否开启检查黑名单列表--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span> <span class="attr">check</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--黑名单允许的 权限 后面为默认--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;selelctAllow&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>黑名单配置拦截明细如下：</strong></p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">缺省值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rollbackAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 roll back 操作,如果把 selectIntoAllow、deleteAllow、updateAllow、insertAllow、mergeAllow 都设置为 false，这就是一个只读数据源了。</td>
</tr>
<tr>
<td align="center">selectAllow</td>
<td align="center">true</td>
<td align="center">是否运行执行SELECT语句</td>
</tr>
<tr>
<td align="center">selectAllColumnAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 SELECT * FROM T 这样的语句。如果设置为 false，不允许执行 select * from t，但 select * from (select id, name from t) a。这个选项是防御程序通过调用 select *获得数据表的结构信息</td>
</tr>
<tr>
<td align="center">selectIntoAllow</td>
<td align="center">true</td>
<td align="center">SELECT 查询中是否允许 INTO 字句</td>
</tr>
<tr>
<td align="center">deleteAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 DELETE 语句</td>
</tr>
<tr>
<td align="center">updateAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 UPDATE 语句</td>
</tr>
<tr>
<td align="center">insertAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 INSERT 语句</td>
</tr>
<tr>
<td align="center">replaceAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 REPLACE 语句</td>
</tr>
<tr>
<td align="center">mergeAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 MERGE 语句，这个只在 Oracle 中有用</td>
</tr>
<tr>
<td align="center">callAllow</td>
<td align="center">true</td>
<td align="center">是否允许通过 jdbc 的 call 语法调用存储过程</td>
</tr>
<tr>
<td align="center">setAllow</td>
<td align="center">true</td>
<td align="center">是否允许使用 SET 语法</td>
</tr>
<tr>
<td align="center">truncateAllow</td>
<td align="center">true</td>
<td align="center">truncate 语句是危险，缺省打开，若需要自行关闭</td>
</tr>
<tr>
<td align="center">createTableAllow</td>
<td align="center">true</td>
<td align="center">是否允许创建表</td>
</tr>
<tr>
<td align="center">alterTableAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 Alter Table 语句</td>
</tr>
<tr>
<td align="center">dropTableAllow</td>
<td align="center">true</td>
<td align="center">是否允许修改表</td>
</tr>
<tr>
<td align="center">commentAllow</td>
<td align="center">false</td>
<td align="center">是否允许语句中存在注释，Oracle 的用户不用担心，Wall 能够识别 hints和注释的区别</td>
</tr>
<tr>
<td align="center">noneBaseStatementAllow</td>
<td align="center">false</td>
<td align="center">是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项 就能够屏蔽 DDL。</td>
</tr>
<tr>
<td align="center">multiStatementAllow</td>
<td align="center">false</td>
<td align="center">是否允许一次执行多条语句，缺省关闭</td>
</tr>
<tr>
<td align="center">useAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 mysql 的 use 语句，缺省打开</td>
</tr>
<tr>
<td align="center">describeAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 mysql 的 describe 语句，缺省打开</td>
</tr>
<tr>
<td align="center">showAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 mysql 的 show 语句，缺省打开</td>
</tr>
<tr>
<td align="center">commitAllow</td>
<td align="center">true</td>
<td align="center">是否允许执行 commit 操作</td>
</tr>
</tbody></table>
<p><strong>拦截配置=-永真条件：</strong></p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">缺省值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">selectWhereAlwayTrueCheck</td>
<td align="center">true</td>
<td align="center">检查 SELECT 语句的 WHERE 子句是否是一个永真条件</td>
</tr>
<tr>
<td align="center">selectHavingAlwayTrueCheck</td>
<td align="center">true</td>
<td align="center">检查 SELECT 语句的 HAVING 子句是否是一个永真条件</td>
</tr>
<tr>
<td align="center">deleteWhereAlwayTrueCheck</td>
<td align="center">true</td>
<td align="center">检查 DELETE 语句的 WHERE 子句是否是一个永真条件</td>
</tr>
<tr>
<td align="center">deleteWhereNoneCheck</td>
<td align="center">false</td>
<td align="center">检查 DELETE 语句是否无 where 条件，这是有风险的，但不是 SQL 注入类型的风险</td>
</tr>
<tr>
<td align="center">updateWhereAlayTrueCheck</td>
<td align="center">true</td>
<td align="center">检查 UPDATE 语句的 WHERE 子句是否是一个永真条件</td>
</tr>
<tr>
<td align="center">updateWhereNoneCheck</td>
<td align="center">false</td>
<td align="center">检查 UPDATE 语句是否无 where 条件，这是有风险的，但不是SQL 注入类型的风险</td>
</tr>
<tr>
<td align="center">conditionAndAlwayTrueAllow</td>
<td align="center">false</td>
<td align="center">检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永真条件</td>
</tr>
<tr>
<td align="center">conditionAndAlwayFalseAllow</td>
<td align="center">false</td>
<td align="center">检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永假条件</td>
</tr>
<tr>
<td align="center">conditionLikeTrueAllow</td>
<td align="center">true</td>
<td align="center">检查查询条件(WHERE/HAVING 子句)中是否包含 LIKE 永真条件</td>
</tr>
</tbody></table>
<p><strong>其他拦截配置：</strong></p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="left">缺省值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">selectIntoOutfileAllow</td>
<td align="left">false</td>
<td align="center">SELECT … INTO OUTFILE 是否允许，这个是 mysql 注入攻击的常见手段，缺省是禁止的</td>
</tr>
<tr>
<td align="center">selectUnionCheck</td>
<td align="left">true</td>
<td align="center">检测 SELECT UNION</td>
</tr>
<tr>
<td align="center">selectMinusCheck</td>
<td align="left">true</td>
<td align="center">检测 SELECT MINUS</td>
</tr>
<tr>
<td align="center">selectExceptCheck</td>
<td align="left">true</td>
<td align="center">检测 SELECT EXCEPT</td>
</tr>
<tr>
<td align="center">selectIntersectCheck</td>
<td align="left">true</td>
<td align="center">检测 SELECT INTERSECT</td>
</tr>
<tr>
<td align="center">mustParameterized</td>
<td align="left">false</td>
<td align="center">是否必须参数化，如果为 True，则不允许类似 WHERE ID = 1 这种不参数化的 SQL</td>
</tr>
<tr>
<td align="center">strictSyntaxCheck</td>
<td align="left">true</td>
<td align="center">是否进行严格的语法检测，Druid SQL Parser 在某些场景不能覆盖所有的，SQL 语法，出现解析 SQL 出错，可以临时把这个选项设置为 false，同时把 SQL 反馈给 Druid 的开发者</td>
</tr>
<tr>
<td align="center">conditionOpXorAllow</td>
<td align="left">false</td>
<td align="center">查询条件中是否允许有 XOR 条件。XOR 不常用，很难判断永真或者永假，缺省不允许。</td>
</tr>
<tr>
<td align="center">conditionOpBitwseAllow</td>
<td align="left">true</td>
<td align="center">查询条件中是否允许有”&amp;”、”~”、”</td>
</tr>
<tr>
<td align="center">conditionDoubleConstAllow</td>
<td align="left">false</td>
<td align="center">查询条件中是否允许连续两个常量运算表达式</td>
</tr>
<tr>
<td align="center">minusAllow</td>
<td align="left">true</td>
<td align="center">是否允许 SELECT * FROM A MINUS SELECT * FROM B 这样的语句</td>
</tr>
<tr>
<td align="center">intersectAllow</td>
<td align="left">true</td>
<td align="center">是否允许 SELECT * FROM A INTERSECT SELECT * FROM B 这样的语句</td>
</tr>
<tr>
<td align="center">constArithmeticAllow</td>
<td align="left">true</td>
<td align="center">拦截常量运算的条件，比如说 WHERE FID = 3 - 1，其中”3 - 1”是常量运算表达式。</td>
</tr>
<tr>
<td align="center">limitZeroAllow</td>
<td align="left">false</td>
<td align="center">是否允许 limit 0 这样的语句</td>
</tr>
</tbody></table>
<p><strong>禁用对象检测配置：</strong></p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">缺省值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tableCheck</td>
<td align="center">true</td>
<td align="center">检测是否使用了禁用的表</td>
</tr>
<tr>
<td align="center">schemaCheck</td>
<td align="center">true</td>
<td align="center">检测是否使用了禁用的 Schema</td>
</tr>
<tr>
<td align="center">functionCheck</td>
<td align="center">true</td>
<td align="center">检测是否使用了禁用的函数</td>
</tr>
<tr>
<td align="center">objectCheck</td>
<td align="center">true</td>
<td align="center">检测是否使用了“禁用对对象”</td>
</tr>
<tr>
<td align="center">variantCheck</td>
<td align="center">true</td>
<td align="center">检测是否使用了“禁用的变量”</td>
</tr>
<tr>
<td align="center">readOnlyTables</td>
<td align="center">空</td>
<td align="center">指定的表只读，不能够在 SELECT INTO、DELETE、UPDATE、INSERT、MERGE 中作为”被修改表”出现</td>
</tr>
</tbody></table>
<h4 id="5-2-5-mycat配置文件"><a href="#5-2-5-mycat配置文件" class="headerlink" title="5.2.5 mycat配置文件"></a>5.2.5 mycat配置文件</h4><h5 id="5-2-5-1-schema-xml配置"><a href="#5-2-5-1-schema-xml配置" class="headerlink" title="5.2.5.1 schema.xml配置"></a>5.2.5.1 schema.xml配置</h5><p>schema.xml作为mycat中重要的配置文件之一，管理者mycat的逻辑库、表、分片规则、DataNode以及DataSource。</p>
<h5 id="5-2-5-2-scheme标签"><a href="#5-2-5-2-scheme标签" class="headerlink" title="5.2.5.2 scheme标签"></a>5.2.5.2 scheme标签</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>schema标签用于定义mycat实例中的逻辑库，mycat可以由多个逻辑库，每个逻辑库都有自己的相关配置，可以使用schema标签来划分这些不同的逻辑库。如果不配置schema标签，所有的表配置，会属于同一个默认的逻辑库。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--逻辑库TESTDB--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;travelrecord&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--USERDB--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;USERDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;company&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn10,dn11,dn12&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	逻辑库的概念和MySQL数据库中的database概念相同，我们在查询这两个不同的逻辑库中表的时候需要切换到该逻辑库下才可以查询到所需要的表</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>在server.xml中可以配置不同的用户能够使用的schema</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSchema&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--No MyCAT Database selected 错误前会尝试使用该schema作为schema，不设置则为null,报错 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;privileges check=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="comment">                &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">                        &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">                        &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">                &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">        &lt;/privileges&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSchema&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/23/mycat/image-20201129110838590.png"></p>
<p>schema标签的相关属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">值</th>
<th align="center">数量限制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dataNode</td>
<td align="center">任意string</td>
<td align="center">（0..1）</td>
</tr>
<tr>
<td align="center">checkSQLschema</td>
<td align="center">Boolean</td>
<td align="center">（1）</td>
</tr>
<tr>
<td align="center">sqlMaxLimit</td>
<td align="center">Integer</td>
<td align="center">（1）</td>
</tr>
</tbody></table>
<h6 id="5-2-5-2-1-dataNode"><a href="#5-2-5-2-1-dataNode" class="headerlink" title="5.2.5.2.1  dataNode"></a>5.2.5.2.1  dataNode</h6><p>该属性用于绑定逻辑库到某个具体的database上，1.3版本如果配置了dataNode,则不可以配置分片表，1.4可以配置默认分片，只需要配置需要分片的表即可，具体配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.3版本配置--&gt;</span><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;USERDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span>&lt;!—里面不能配置任何表--&gt;<span class="tag">&lt;/<span class="name">schema</span>&gt;</span><span class="comment">&lt;!--1.4版本配置--&gt;</span><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;USERDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span>&gt;</span>&lt;!—配置需要分片的表--&gt;	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">“tuser”</span> <span class="attr">dataNode</span>=<span class="string">”dn1”/</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span><span class="comment">&lt;!-- 	那么现在tuser就绑定到dn1所配置的具体database上，可以直接访问这个database，没有配置的表则会走默认的节点dn2，这里注意没有配置在分片里面的表工具查看无法显示，但是可以正常使用。--&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="5-2-5-2-2-checkSQLschema"><a href="#5-2-5-2-2-checkSQLschema" class="headerlink" title="5.2.5.2.2 checkSQLschema"></a>5.2.5.2.2 checkSQLschema</h6><p>当改制设置为true时，我们执行“SELECT * FROM TESTDB.travelrecord；”则mycat会把语句修改为“SELECT * FROM travelrecord;”即把表示schema的字符去掉，避免发送到后端数据库执行报ERROR 1146：Table ‘testdb.travelrecord’ doest’t exist.不过，即使设置该值为 true ，如果语句所带的是并非是 schema 指定的名字，例如：<strong>select * from db1.travelrecord;</strong> 那么 MyCat 并不会删除 db1 这个字段，如果没有定义该库的话则会报错，所以在提供 SQL语句的最好是不带这个字段。</p>
<h6 id="5-2-5-2-3-sqlMaxLimit"><a href="#5-2-5-2-3-sqlMaxLimit" class="headerlink" title="5.2.5.2.3 sqlMaxLimit"></a>5.2.5.2.3 sqlMaxLimit</h6><p>当该值设置为某个数值时。每条执行的 SQL 语句，如果没有加上 limit 语句，MyCat 也会自动的加上所对应的值。例如设置值为 100，执行**select * from TESTDB.travelrecord;<strong>的效果为和执行</strong>select * from TESTDB.travelrecord limit 100;**相同。</p>
<p>设置该值的话，MyCat 默认会把查询到的信息全部都展示出来，造成过多的输出。所以，在正常使用中，还是建议加上一个值，用于减少过多的数据返回。</p>
<p>当然 SQL 语句中也显式的指定 limit 的大小，不受该属性的约束。</p>
<p>需要注意的是，如果运行的 schema 为非拆分库的，那么该属性不会生效。需要手动添加 limit 语句。</p>
<h3 id="5-2-分配规则"><a href="#5-2-分配规则" class="headerlink" title="5.2 分配规则"></a>5.2 分配规则</h3><p><img src="/2021/07/23/mycat/image-20201104222632963.png" alt="image-20201104222632963"><br><img src="/2021/07/23/mycat/image-20201104221336437.png" alt="image-20201104221336437"></p>
<ul>
<li><p>  范围分片：根据某个字设置auto-sharding-long，如果这个primaryKey超出了范围会报错</p>
</li>
<li><p>  取模分片：</p>
</li>
<li><p>ER分片（将父子表有关联的数据放在一个data-node里面）</p>
<p>  <img src="/2021/07/23/mycat/image-20201104221659540.png" alt="image-20201104221659540"></p>
</li>
<li><p>  全局表：所有dataNode存储相同的数据，查询的时候是随机查询某个表 type=global，查询的时候随机从某个datanode获取</p>
</li>
<li><p>  非分片表：只在某个dataNode上存储,指定一个dataNode并且不写分片规则</p>
</li>
<li><p>  单库分表：有个bug在实际数据库中必须要创建mycat中一摸一样的数据表，而且truncat的时候要现在dataNode先删除，才能删除的掉mycat的数据</p>
</li>
</ul>
<h3 id="5-3-全局ID"><a href="#5-3-全局ID" class="headerlink" title="5.3 全局ID"></a>5.3 全局ID</h3><p><img src="/2021/07/23/mycat/image-20201104223246735.png" alt="image-20201104223246735"></p>
<ul>
<li>  文件方式—0</li>
<li>  数据库方式—1</li>
<li>  本地时间戳—-2</li>
<li>  ZK方式—-3</li>
</ul>
<h2 id="6-Mycat分片策略详解"><a href="#6-Mycat分片策略详解" class="headerlink" title="6. Mycat分片策略详解"></a>6. Mycat分片策略详解</h2><p>连续分片与离散分片</p>
<p><img src="/2021/07/23/mycat/image-20201107201442912.png" alt="image-20201107201442912"></p>
<p><strong>连续分片</strong>：</p>
<ul>
<li>  范围分片</li>
<li>  日期/事件</li>
</ul>
<p>缺点：</p>
<ul>
<li>  存在数据热点的可能性</li>
<li>  并发访问能力受限于单一或少量DataNode（访问集中），并不能分摊数据库访问的压力</li>
</ul>
<p><strong>离散</strong>：</p>
<ul>
<li><p>  取模（partioncount 的总数必须和分片总数相同）</p>
</li>
<li><p>  枚举</p>
</li>
<li><p>  一致性哈希(qs-murmur)</p>
</li>
<li><p>固定分片哈希</p>
<ul>
<li><p>  partitionCount: 2, 1表示有三个分片必须和节点数量一致，否则会报错，前面两个一样长</p>
</li>
<li><p>  partitionLength: 256, 512表示长度为256和512</p>
</li>
<li><p>  综合在一起就是前面2个分片长度为256， 最后一个为512，结果如下图所示（注意partitionCount和partitionLength的数量一定要一致）</p>
</li>
<li><p><img src="/2021/07/23/mycat/image-20201219103201836.png" alt="image-20201219103201836"></p>
<p>  <img src="/2021/07/23/mycat/image-20201219102742172.png" alt="image-20201219102742172"></p>
</li>
</ul>
</li>
<li><p>  取模范围(sharting-by-pattern)：先取模PartitionByPattern后分片</p>
</li>
<li><p>范围取模: PartitionByRangeMod(partition-rane-mod.txt)</p>
<ul>
<li>```txt<br>  0-2000=1        #范围在2000以内的在第一个节点（取模的结果还是本身）<br>  2001-4000=2        #范围在2001到4000以内的再模2，结果为0在第一个节点，结果为1在第三个节点  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-   其他</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">-   并发访问能力增强（负载到不同的节点）</span><br><span class="line">-   范围条件查询性能提升（并行计算）</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">-   数据扩容比较困难，设计到数据迁移问题</span><br><span class="line">-   数据库连接消耗比较多</span><br><span class="line"></span><br><span class="line">分片策略的选择：</span><br><span class="line"></span><br><span class="line">1） 确定分片表</span><br><span class="line"></span><br><span class="line">2） 找出分片键</span><br><span class="line"></span><br><span class="line">3） 考虑容量、增速、业务用户</span><br><span class="line"></span><br><span class="line">如果在查询语句中没有携带分片建，那么mycat会将sql发布到所有的节点上</span><br><span class="line"></span><br><span class="line">## 7. Mycat扩缩容</span><br><span class="line"></span><br><span class="line">### 7.1 在线不停机扩缩容（双写）</span><br><span class="line"></span><br><span class="line">![image-20201107205855474](./mycat/image-20201107205855474.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.2 离线扩缩容</span><br><span class="line"></span><br><span class="line">#### 7.2.1Mysql Dump</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">mysqldump -uroot -p123456 -h127.0.0.1 -p3306 -c -t --skip-extended-insert 数据库名称 &gt; mysql.11.11.sql</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="7-2-2-Mycat自带工具"><a href="#7-2-2-Mycat自带工具" class="headerlink" title="7.2.2 Mycat自带工具"></a>7.2.2 Mycat自带工具</h4><ol>
<li> mycat所在环境安装mysql客户端程序</li>
<li> mycat的lib目录下添加mysql的jdbc驱动包（mysql-connector-java-5.7.1.jar）</li>
<li> 对扩容缩容的表所有节点数据进行备份</li>
<li> 复制schema.xml、rule.xml并重命名为newSchema.xml、newRule.xml</li>
<li> 修改newSchema.xml和newRule.xml配置文件为扩容缩容后的参数</li>
<li> 在conf/migrateTable.properties配置文件中配置分片库和分片表如：imall=table_test1</li>
<li> dataMigrate.sh配置mysqldump路径</li>
<li> 停止mycat服务</li>
<li> 执行bin/dataMigrate.sh脚本（不能用openjdk）</li>
<li> 替换schema.xml、rule.xml</li>
</ol>
<p><strong>注意事项：</strong></p>
<ul>
<li>  保证分片表迁移数据前后路由规则一致（取模–&gt;取模）</li>
<li>  保证分片表歉意数据前后分片字段一致</li>
<li>  全局表将被忽略</li>
<li>  不要将非分片表配置到migrateTables.properties文件中</li>
<li>  暂时只支持分片表使用Mysql作为数据源的扩容缩容</li>
</ul>
<h2 id="8-Mycat读写分离"><a href="#8-Mycat读写分离" class="headerlink" title="8. Mycat读写分离"></a>8. Mycat读写分离</h2><h3 id="8-1-主从复制"><a href="#8-1-主从复制" class="headerlink" title="8.1 主从复制"></a>8.1 主从复制</h3><ol>
<li> 数据备份回复</li>
<li> 负载均衡（读写分离）</li>
<li> 高可用HA</li>
</ol>
<h3 id="8-2-主从复制形式"><a href="#8-2-主从复制形式" class="headerlink" title="8.2 主从复制形式;"></a>8.2 主从复制形式;</h3><p><img src="/2021/07/23/mycat/image-20201107212552852.png" alt="image-20201107212552852"></p>
<h4 id="binlog-Binary-log-二进制日志"><a href="#binlog-Binary-log-二进制日志" class="headerlink" title="binlog(Binary log 二进制日志)"></a>binlog(Binary log 二进制日志)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看binglog: SHOW binlog events in &#x27;mysql-bin.000001&#x27;</span></span><br><span class="line"><span class="comment">--show variables like &#x27;max_blog_max&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="binlog配置"><a href="#binlog配置" class="headerlink" title="binlog配置"></a>binlog配置</h4><ul>
<li>  STATEMENT: 记录每一天修改数据的sql语句（减少日志量，节约IO）</li>
<li>  ROW: 记录哪条数据被修改了，修改成什么样子了（5.7以后默认）</li>
<li>  MIXED: 结合两种方式，一般语句用STATEMENT,函数之类的使用ROW</li>
</ul>
<p><strong>binlog</strong>格式（mysql-bin.00001等）</p>
<p><strong>查看binlog</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.00001&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>SQL Thread是单线程的， 这也是所有的主从复制延迟的原因，那么relay log接受master节点的sql语句主要是用于缓冲</p>
<p><img src="/2021/07/23/mycat/image-20201107213638624.png" alt="image-20201107213638624"></p>
<h3 id="mycat读写分离配置"><a href="#mycat读写分离配置" class="headerlink" title="mycat读写分离配置"></a>mycat读写分离配置</h3><p><img src="/2021/07/23/mycat/image-20201107213859155.png" alt="image-20201107213859155"></p>
<h3 id="8-5-Mycat注解（hint）"><a href="#8-5-Mycat注解（hint）" class="headerlink" title="8.5 Mycat注解（hint）"></a>8.5 Mycat注解（hint）</h3><p>注解用法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/*!mycat:sql=注解sql语句*/真正执行的SQL</span><br><span class="line"></span><br><span class="line">比如说在mycat上创建表无法创建成功，可以使用注解</span><br><span class="line">/*!mycat:sql=select * from table<span class="built_in">_</span>1 where id = 1*/create table test2(id int);</span><br><span class="line">主要注解sql可以确认mycat可以路由到子结点上，就可以执行后面的真正执行的sql语句</span><br></pre></td></tr></table></figure>

<p>注解用途：</p>
<ul>
<li>  跨库关联查询</li>
<li>  DDL或存储过程</li>
<li>  自定义分片</li>
<li>  读写分离</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>基于XA协议的两阶段提交</p>
<p><img src="/2021/07/23/mycat/image-20201107215437139.png" alt="image-20201107215437139"></p>
<h4 id="XA角色"><a href="#XA角色" class="headerlink" title="XA角色"></a>XA角色</h4><p><img src="/2021/07/23/mycat/image-20201107215605251.png" alt="image-20201107215605251"></p>
<h4 id="XA实现"><a href="#XA实现" class="headerlink" title="XA实现"></a>XA实现</h4><p><img src="/2021/07/23/mycat/image-20201107220049532.png" alt="image-20201107220049532"></p>
<h2 id="9-Mycat核心流程"><a href="#9-Mycat核心流程" class="headerlink" title="9. Mycat核心流程"></a>9. Mycat核心流程</h2><h3 id="9-1-架构图"><a href="#9-1-架构图" class="headerlink" title="9.1 架构图"></a>9.1 架构图</h3><p><img src="/2021/07/23/mycat/image-20201220170713526.png" alt="image-20201220170713526"></p>
<h3 id="9-2-启动流程"><a href="#9-2-启动流程" class="headerlink" title="9.2 启动流程"></a>9.2 启动流程</h3><ol>
<li> MycatServer启动，解析配置文件，包括服务器、分片规则等</li>
<li> 创建工作线程，建立前端连接和后端连接</li>
</ol>
<h3 id="9-3-执行SQL流程"><a href="#9-3-执行SQL流程" class="headerlink" title="9.3 执行SQL流程"></a>9.3 执行SQL流程</h3><ol>
<li> 前端连接接收mysql命令</li>
<li> 解析MySQL，mycat用的是Druid的DruidParser</li>
<li> 获取路由</li>
<li> 改写MySQL，例如两个条件在两个节点上，则变成两条单独的sql</li>
<li> 与后端数据库建立连接</li>
<li> 发送sql语句到MySQL执行</li>
<li> 获取返回结果</li>
<li> 处理返回结果，例如排序、计算等等</li>
<li> 返回给客户端</li>
</ol>
<h2 id="Mycat高可用"><a href="#Mycat高可用" class="headerlink" title="Mycat高可用"></a>Mycat高可用</h2><p><img src="/2021/07/23/mycat/image-20201220172406074.png" alt="image-20201220172406074"></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习</title>
    <url>/2021/07/23/vue/</url>
    <content><![CDATA[<p>Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p>
<h3 id="1-export"><a href="#1-export" class="headerlink" title="1. export"></a>1. export</h3><hr>
<p>用于规定模块的对外接口，export输出变量和方法、类</p>
<ul>
<li><p>变量</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写--优先使用</span></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果想为输入的变量重新命名， 可以使用AS 关键字重新命名</span></span><br><span class="line"><span class="keyword">import</span> &#123; buildMenus <span class="keyword">as</span> buildMenus&#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/menu&#x27;</span>;</span><br><span class="line"><span class="comment">//import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-export-default"><a href="#2-export-default" class="headerlink" title="2. export default"></a>2. export default</h3><p>为模块指定默认输出， 使用import命令的时候，用户需要知道所要加载的变量名和函数名，否则无法加载；了解模块有哪些方法和属性比较麻烦，使用export default命令，为模块指定默认输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个模块文件export-default.js。默认输出1个函数；</p>
<p>与export命令的区别：其他模块加载该模块是，import命令可以为该匿名函数指定任意名字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>
<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>
<p><strong>总结：</strong></p>
<ul>
<li><p>  export命令对外接口是有名称的且<code>import</code>命令从模块导入的变量名与被导入模块对外接口的名称相同，而export default命令对外输出的变量名可以是任意的，这时<code>import</code>命令后面，不使用大括号。</p>
</li>
<li><p>  <code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//menu.js</span></span><br><span class="line"><span class="comment">//get请求获取所有的菜单信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">buildMenus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;api/menus/build&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//post 请求保存数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;api/menus&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//delete 请求删除数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;api/menus/&#x27;</span> + id,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//put请求修改数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;api/menus&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; buildMenus &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/menu&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-Const、var、let"><a href="#3-Const、var、let" class="headerlink" title="3. Const、var、let"></a>3. Const、var、let</h3><p> ES5 中作用域有：全局作用域、函数作用域。没有块作用域的概念。</p>
<p> ES6 中新增了块级作用域。块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 通过var定义的变量可以跨块作用域访问到。</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// console.log(b); // 报错，</span></span><br><span class="line"><span class="comment">// 可见，通过var定义的变量不能跨函数作用域访问到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 4   (循环结束i已经是4，所以此处i为4)</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// if语句和for语句中用var定义的变量可以在外面访问到，</span></span><br><span class="line"><span class="comment">// 可见，if语句和for语句属于块作用域，不属于函数作用域</span></span><br></pre></td></tr></table></figure>

<p>三者的区别：</p>
<ol>
<li> var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。</li>
<li> let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li>
<li> const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 块作用域</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// c = 4; // 报错</span></span><br><span class="line">  <span class="keyword">var</span> aa;</span><br><span class="line">  <span class="keyword">let</span> bb;</span><br><span class="line">  <span class="comment">// const cc; // 报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(bb); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// console.log(b); // 报错</span></span><br><span class="line"><span class="comment">// console.log(c); // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">let</span> e = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(d); <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// 6  </span></span><br><span class="line">  <span class="built_in">console</span>.log(f); <span class="comment">// 7 </span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// console.log(d); // 报错</span></span><br><span class="line"><span class="comment">// console.log(e); // 报错</span></span><br><span class="line"><span class="comment">// console.log(f); // 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：<strong>const定义的对象属性是否可以改变</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&#x27;jiuke&#x27;</span>,</span><br><span class="line">  <span class="attr">sex</span> : <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)<span class="comment">//person对象的name属性确实被修改了</span></span><br></pre></td></tr></table></figure>

<p>因为对象是引用类型的，person中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。</p>
<p>然后我们试着修改一下指针，让person指向一个新对象，果然报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">   <span class="attr">name</span> : <span class="string">&#x27;jiuke&#x27;</span>,</span><br><span class="line">   <span class="attr">sex</span> : <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">person = &#123;</span><br><span class="line">   <span class="attr">name</span> : <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">   <span class="attr">sex</span> : <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h3 id="4-promise"><a href="#4-promise" class="headerlink" title="4. promise"></a>4. promise</h3><p>promise用途：异步编程的一种解决方案。</p>
<p>优点：比传统的解决方案——回调函数和事件——更合理和更强大。</p>
<p>三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本用法：</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(value);<span class="comment">//表示异步操作成功</span></span><br><span class="line">    reject(error);<span class="comment">//表示异步操作失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise常用的几个方法</span></span><br><span class="line"><span class="comment">//1. 异步状态为成功时调用第一个函数，为失败时调用第二个函数。then方法的第二个参数可选。</span></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 异步状态为失败时调用。</span></span><br><span class="line">promise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. promise异步状态为失败时或then方法中抛出错误都会执行catch方法。</span></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 不管状态如何都会执行的操作。</span></span><br><span class="line">promise.finally(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h3><img src="https://cn.vuejs.org/images/lifecycle.png" alt="img" style="zoom:50%;">

<h3 id="6-模版语法"><a href="#6-模版语法" class="headerlink" title="6. 模版语法"></a>6. 模版语法</h3><h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h4><p>执行一次性插值，当数据变化的时候，该内容不会更新；可能会影响该节点其他的数据绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用v-html;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var rawHtml = &quot;<span class="tag">&lt;<span class="name">span</span>&gt;</span>这是个使用v-htmls<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#Attribute">Attribute</a></h4><p>Mustache ({}) 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <a href="https://cn.vuejs.org/v2/api/#v-bind"><code>v-bind</code> 指令</a>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 <span class="tag">&lt;<span class="name">button</span>&gt;</span> 元素中</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。</span><br><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-指令Directives"><a href="#7-指令Directives" class="headerlink" title="7. 指令Directives"></a>7. 指令Directives</h3><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//v-if 指令将根据表达式 seen 的值的真假来插入/移除 <span class="tag">&lt;<span class="name">p</span>&gt;</span> 元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p> 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>] = <span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	这里的attributeName会被作为一个javascript表达式进行动态赋值，求得的值会作为最终的参数来使用</span></span><br><span class="line"><span class="comment">如果VUE实例有一个data. property. attributeName， 其值为href， 那么绑定将等价于v-bind:href</span></span><br><span class="line"><span class="comment">---&gt;</span></span><br></pre></td></tr></table></figure>

<p>绑定处理函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;dosomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对动态参数的值的约束</p>
<p>  动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p>
</li>
<li><p>对动态参数表达式的约束</p>
<p>  动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p>
</li>
</ul>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符（modifier）是以半角句号<code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定；例如<code> .prevent</code>修饰符告诉v-on指令对触发的事件调用event.preventDefault();</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span> = <span class="string">&quot;onSubmit&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>:</code> 与 <code>@</code> 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。</p>
<h3 id="8-计算属性"><a href="#8-计算属性" class="headerlink" title="8. 计算属性"></a>8. 计算属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    <span class="attr">reversedMessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面显示：</span></span><br><span class="line"><span class="comment">//Original message: &quot;Hello&quot;</span></span><br><span class="line"><span class="comment">//Computed reversed message: &quot;olleH&quot;</span></span><br></pre></td></tr></table></figure>

<p>声明了一个计算属性<code>reversedMessage</code>；我们提供的函数将用作property <code>vm.reversedMessage</code>的getter函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// olleH</span></span><br><span class="line">vm.message = <span class="string">&#x27;Goodbye&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; &#x27;eybdooG&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你可以打开浏览器的控制台，自行修改例子中的 vm。<code>vm.reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值。</p>
<p>你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code>，因此当 <code>vm.message</code> 发生改变时，所有依赖 <code>vm.reversedMessage</code> 的绑定也会更新。以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的。</p>
<h4 id="计算属性-VS-方法"><a href="#计算属性-VS-方法" class="headerlink" title="计算属性 VS 方法"></a>计算属性 VS 方法</h4><p>使用表达式中调用方法同样可以达到上面的结果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">reversedMessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p>
<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <strong>A</strong>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong>。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter！如果你不希望有缓存，请用方法来替代。</p>
<h4 id="计算属性-VS-侦听属性"><a href="#计算属性-VS-侦听属性" class="headerlink" title="计算属性 VS 侦听属性"></a>计算属性 VS 侦听属性</h4><p>侦听属性：vue提供了一种更通用的方式来观察和响应vue实例上的数据变动；当有一些数据需要随着其他数据变动而变动时；很容易滥用watch;<strong>通常更好的做法是使用计算属性而不是命令式的watch回调</strong>；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    <span class="attr">fullName</span>: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//侦听属性watch </span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//计算属性</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h4><p>计算属性默认只有getter，自己可以提供一个setter</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>
<h3 id="9-侦听器"><a href="#9-侦听器" class="headerlink" title="9. 侦听器"></a>9. 侦听器</h3><p>当需要在数据变化时执行异步或开销较大的操作时，watch是最有用的；同时也可以自定义侦听器；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="line">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">el</span>: <span class="string">&#x27;#watch-example&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">question</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.answer = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.debouncedGetAnswer()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.debouncedGetAnswer = _.debounce(<span class="built_in">this</span>.getAnswer, <span class="number">500</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">getAnswer</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">if</span> (<span class="built_in">this</span>.question.indexOf(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.answer = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.answer = <span class="string">&#x27;Thinking...&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> vm = <span class="built_in">this</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      axios.get(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          vm.answer = _.capitalize(response.data.answer)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//异常捕获</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          vm.answer = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用 <code>watch</code> 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的</p>
<h3 id="10-class与style绑定"><a href="#10-class与style绑定" class="headerlink" title="10. class与style绑定"></a>10. class与style绑定</h3><p>将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组</p>
<h4 id="10-1-绑定html-class"><a href="#10-1-绑定html-class" class="headerlink" title="10.1 绑定html class"></a>10.1 绑定html class</h4><h5 id="10-1-1对象语法"><a href="#10-1-1对象语法" class="headerlink" title="10.1.1对象语法"></a>10.1.1对象语法</h5><p>方式一：内联</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//data</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：绑定的数据对象不必内联定义在模板里</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//vue data</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式三：绑定一个返回对象的计算属性（常用）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//vue data</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-1-2-数组语法"><a href="#10-1-2-数组语法" class="headerlink" title="10.1.2 数组语法"></a>10.1.2 数组语法</h5>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
